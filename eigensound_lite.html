<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Eigensound Lite - Quantum Sonification</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background: linear-gradient(135deg, #0c1445 0%, #1a0b3d 50%, #2d1b4e 100%);
            color: #e0e6ff;
            overflow-x: hidden;
            min-height: 100vh;
            touch-action: manipulation;
        }

        .container {
            max-width: 100vw;
            margin: 0 auto;
            padding: 1rem;
        }

        .header {
            text-align: center;
            margin-bottom: 2rem;
            padding: 1rem;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .header h1 {
            font-size: 1.8rem;
            font-weight: 300;
            letter-spacing: 2px;
            margin-bottom: 0.5rem;
            background: linear-gradient(45deg, #00d4ff, #9d4edd);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .header .subtitle {
            font-size: 0.9rem;
            opacity: 0.8;
            margin-bottom: 1rem;
        }

        .tabs {
            display: flex;
            margin-bottom: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 4px;
        }

        .tab {
            flex: 1;
            padding: 0.75rem;
            text-align: center;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9rem;
            user-select: none;
        }

        .tab.active {
            background: linear-gradient(45deg, #00d4ff, #9d4edd);
            color: white;
            box-shadow: 0 4px 15px rgba(157, 78, 221, 0.3);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .visualization-container {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 15px;
            padding: 1rem;
            margin-bottom: 1.5rem;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .wavefunction-canvas {
            width: 100%;
            height: 200px;
            border-radius: 10px;
            background: radial-gradient(circle at center, rgba(0, 212, 255, 0.1), transparent);
            border: 1px solid rgba(0, 212, 255, 0.3);
            touch-action: none;
        }

        .energy-levels {
            margin-top: 1rem;
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
        }

        .energy-level {
            background: linear-gradient(45deg, rgba(0, 212, 255, 0.6), rgba(157, 78, 221, 0.6));
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.3s ease;
            user-select: none;
        }

        .energy-level:hover, .energy-level.playing {
            transform: scale(1.1);
            box-shadow: 0 4px 15px rgba(0, 212, 255, 0.5);
        }

        .controls-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 1rem;
            margin-bottom: 1.5rem;
        }

        @media (min-width: 768px) {
            .controls-grid {
                grid-template-columns: 1fr 1fr;
            }
        }

        .control-group {
            background: rgba(255, 255, 255, 0.05);
            padding: 1rem;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .control-label {
            display: block;
            margin-bottom: 0.75rem;
            font-size: 0.9rem;
            font-weight: 500;
            color: #00d4ff;
        }

        .slider-container {
            position: relative;
            margin-bottom: 0.5rem;
        }

        .slider {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.2);
            outline: none;
            appearance: none;
            -webkit-appearance: none;
            cursor: pointer;
        }

        .slider::-webkit-slider-thumb {
            appearance: none;
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(45deg, #00d4ff, #9d4edd);
            cursor: pointer;
            box-shadow: 0 2px 10px rgba(0, 212, 255, 0.5);
            transition: transform 0.2s ease;
        }

        .slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
        }

        .slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(45deg, #00d4ff, #9d4edd);
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 10px rgba(0, 212, 255, 0.5);
        }

        .slider-value {
            position: absolute;
            right: 0;
            top: -25px;
            font-size: 0.8rem;
            color: #00d4ff;
            font-weight: 500;
        }

        .action-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
            margin-bottom: 1.5rem;
        }

        .btn {
            padding: 1rem;
            border: none;
            border-radius: 12px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            user-select: none;
        }

        .btn-primary {
            background: linear-gradient(45deg, #00d4ff, #0099cc);
            color: white;
        }

        .btn-secondary {
            background: linear-gradient(45deg, #9d4edd, #7b2cbf);
            color: white;
        }

        .btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .preset-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 0.75rem;
            margin-bottom: 1.5rem;
        }

        .preset-btn {
            padding: 0.75rem;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            color: #e0e6ff;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
            font-size: 0.85rem;
            user-select: none;
        }

        .preset-btn:hover {
            background: rgba(0, 212, 255, 0.2);
            border-color: #00d4ff;
            transform: translateY(-1px);
        }

        .preset-btn.active {
            background: rgba(0, 212, 255, 0.3);
            border-color: #00d4ff;
        }

        .info-panel {
            background: rgba(0, 0, 0, 0.3);
            padding: 1rem;
            border-radius: 12px;
            border-left: 4px solid #00d4ff;
            margin-bottom: 1rem;
            font-size: 0.9rem;
            line-height: 1.4;
        }

        .recording-indicator {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #ff4757;
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-size: 0.8rem;
            opacity: 0;
            transition: opacity 0.3s ease;
            z-index: 1000;
        }

        .recording-indicator.active {
            opacity: 1;
            animation: pulse 1s infinite;
        }

        .tooltip {
            position: relative;
            display: inline-block;
        }

        .tooltip .tooltiptext {
            visibility: hidden;
            width: 280px;
            background-color: rgba(0, 0, 0, 0.9);
            color: #fff;
            text-align: left;
            border-radius: 8px;
            padding: 8px 12px;
            position: absolute;
            z-index: 1000;
            bottom: 125%;
            left: 50%;
            margin-left: -140px;
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 0.8rem;
            line-height: 1.3;
            border: 1px solid rgba(0, 212, 255, 0.3);
        }

        .tooltip .tooltiptext::after {
            content: "";
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: rgba(0, 0, 0, 0.9) transparent transparent transparent;
        }

        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }

        .measurement-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }

        .measurement-button {
            padding: 0.5rem;
            border: none;
            border-radius: 8px;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.3s ease;
            background: rgba(255, 255, 255, 0.1);
            color: #e0e6ff;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .measurement-button:hover {
            background: rgba(0, 212, 255, 0.2);
            border-color: #00d4ff;
        }

        .measurement-button.active {
            background: rgba(0, 212, 255, 0.3);
            border-color: #00d4ff;
        }

        .particle-container {
            position: relative;
            height: 60px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            margin-top: 1rem;
            overflow: hidden;
        }

        .quantum-particle {
            position: absolute;
            width: 12px;
            height: 12px;
            background: radial-gradient(circle, #00d4ff, #0099cc);
            border-radius: 50%;
            box-shadow: 0 0 15px #00d4ff;
            transition: all 0.3s ease;
            opacity: 0;
        }

        .potential-well-editor {
            touch-action: none;
            cursor: crosshair;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        @media (max-width: 768px) {
            .container {
                padding: 0.5rem;
            }
            
            .header h1 {
                font-size: 1.5rem;
            }
            
            .action-buttons {
                grid-template-columns: 1fr;
            }
            
            .wavefunction-canvas {
                height: 150px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>EIGENSOUND LITE</h1>
            <div class="subtitle">Quantum Mechanics Sonification Platform v0.2.0</div>
            <div class="tabs">
                <div class="tab active" data-tab="synthesizer">Synthesizer</div>
                <div class="tab" data-tab="explorer">Explorer</div>
                <div class="tab" data-tab="sequencer">Sequencer</div>
                <div class="tab" data-tab="about">About</div>
            </div>
        </div>

        <div class="recording-indicator" id="recordingIndicator">● Recording</div>

        <!-- Synthesizer Tab -->
        <div class="tab-content active" id="synthesizer">
            <div class="preset-grid">
                <div class="preset-btn active" data-preset="particle-box">Particle in Box</div>
                <div class="preset-btn" data-preset="harmonic">Harmonic Oscillator</div>
                <div class="preset-btn" data-preset="double-well">Double Well</div>
                <div class="preset-btn" data-preset="step">Step Potential</div>
            </div>

            <div class="visualization-container">
                <canvas class="wavefunction-canvas potential-well-editor" id="wavefunctionCanvas"></canvas>
                <div class="particle-container" id="particleContainer"></div>
                <div class="energy-levels" id="energyLevels"></div>
            </div>

            <div class="controls-grid">
                <div class="control-group">
                    <div class="tooltip">
                        <label class="control-label">Well Width (L)</label>
                        <span class="tooltiptext">Smaller wells = higher energies, more cramped wavefunctions = higher pitch. Controls quantum confinement strength.</span>
                    </div>
                    <div class="slider-container">
                        <input type="range" class="slider" id="wellWidth" min="20" max="200" value="100">
                        <div class="slider-value" id="wellWidthValue">100</div>
                    </div>
                </div>

                <div class="control-group">
                    <div class="tooltip">
                        <label class="control-label">Quantum ↔ Classical</label>
                        <span class="tooltiptext">100% = sharp quantum states with discrete energies, 0% = classical uncertainty with continuous frequencies</span>
                    </div>
                    <div class="slider-container">
                        <input type="range" class="slider" id="quantization" min="0" max="100" value="100">
                        <div class="slider-value" id="quantizationValue">100%</div>
                    </div>
                </div>

                <div class="control-group">
                    <div class="tooltip">
                        <label class="control-label">Decay Rate</label>
                        <span class="tooltiptext">How fast excited atoms release photons and drop to lower energy levels. Controls cascade timing.</span>
                    </div>
                    <div class="slider-container">
                        <input type="range" class="slider" id="decayRate" min="50" max="1000" value="200">
                        <div class="slider-value" id="decayRateValue">200ms</div>
                    </div>
                </div>

                <div class="control-group">
                    <div class="tooltip">
                        <label class="control-label">Synthesis Mode</label>
                        <span class="tooltiptext">Different waveforms create different timbres while preserving quantum energy relationships</span>
                    </div>
                    <div class="slider-container">
                        <input type="range" class="slider" id="synthMode" min="0" max="3" value="0" step="1">
                        <div class="slider-value" id="synthModeValue">Sine</div>
                    </div>
                </div>
            </div>

            <div class="control-group">
                <div class="tooltip">
                    <label class="control-label">Frequency Mapping</label>
                    <span class="tooltiptext">Controls how quantum energy levels are mapped to audible frequencies. Essential for hearing low-energy states.</span>
                </div>
                <div class="controls-grid">
                    <div class="control-group">
                        <label class="control-label">Base Frequency (Hz)</label>
                        <div class="slider-container">
                            <input type="range" class="slider" id="baseFrequency" min="55" max="440" value="110">
                            <div class="slider-value" id="baseFrequencyValue">110</div>
                        </div>
                    </div>
                    <div class="control-group">
                        <label class="control-label">Frequency Scaling</label>
                        <div class="preset-grid" style="margin-bottom: 0;">
                            <div class="preset-btn frequency-mode active" data-freq="linear">Linear</div>
                            <div class="preset-btn frequency-mode" data-freq="log">Logarithmic</div>
                            <div class="preset-btn frequency-mode" data-freq="octave">Octave Fold</div>
                            <div class="preset-btn frequency-mode" data-freq="normalize">Normalize</div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="action-buttons">
                <button class="btn btn-primary" id="exciteButton">Excite System</button>
                <button class="btn btn-secondary" id="recordButton">Record</button>
            </div>

            <div class="controls-grid">
                <div class="control-group">
                    <label class="control-label">Quantum Mode</label>
                    <div class="preset-grid" style="margin-bottom: 0; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));">
                        <div class="preset-btn quantum-mode active" data-mode="cascade">Energy Cascade</div>
                        <div class="preset-btn quantum-mode" data-mode="superposition">Superposition</div>
                        <div class="preset-btn quantum-mode" data-mode="entanglement">Entanglement</div>
                        <div class="preset-btn quantum-mode" data-mode="tunneling">Tunneling Beats</div>
                        <div class="preset-btn quantum-mode" data-mode="coherence">Coherence</div>
                        <div class="preset-btn quantum-mode" data-mode="interference">Interference</div>
                        <div class="preset-btn quantum-mode" data-mode="phase-transition">Phase Transition</div>
                        <div class="preset-btn quantum-mode" data-mode="revival">Quantum Revival</div>
                    </div>
                </div>
                <div class="control-group">
                    <label class="control-label">Profile Management</label>
                    <div class="action-buttons" style="margin-bottom: 0;">
                        <button class="btn btn-secondary" id="saveProfile" style="padding: 0.5rem; font-size: 0.85rem;">Save Profile</button>
                        <button class="btn btn-secondary" id="loadProfile" style="padding: 0.5rem; font-size: 0.85rem;">Load Profile</button>
                    </div>
                    <input type="file" id="fileInput" accept=".json" style="display: none;">
                </div>
            </div>
        </div>

        <!-- Explorer Tab -->
        <div class="tab-content" id="explorer">
            <div class="info-panel">
                <strong>Scientific Mode:</strong> Explore quantum phenomena through direct manipulation of potential wells. Each configuration produces unique sonic signatures that reflect the underlying physics.
            </div>

            <div class="visualization-container">
                <canvas class="wavefunction-canvas" id="explorerCanvas"></canvas>
                <div class="controls-grid">
                    <div class="control-group">
                        <label class="control-label">Potential Shape</label>
                        <div class="slider-container">
                            <input type="range" class="slider" id="potentialShape" min="0" max="4" value="0" step="1">
                            <div class="slider-value" id="potentialShapeValue">Square Well</div>
                        </div>
                    </div>
                    <div class="control-group">
                        <label class="control-label">Barrier Height</label>
                        <div class="slider-container">
                            <input type="range" class="slider" id="barrierHeight" min="0" max="10" value="5" step="0.1">
                            <div class="slider-value" id="barrierHeightValue">5.0</div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="controls-grid">
                <div class="control-group">
                    <label class="control-label">Scientific Analysis</label>
                    <div id="analysisResults" style="font-family: monospace; font-size: 0.8rem; line-height: 1.4; background: rgba(0,0,0,0.3); padding: 0.75rem; border-radius: 6px; min-height: 80px;">
                        <div style="color: #00d4ff;">System Analysis:</div>
                        <div>Energy Levels: <span id="energyCount">-</span></div>
                        <div>Avg Spacing: <span id="avgSpacing">-</span></div>
                        <div>Quantum Number: <span id="maxQuantum">-</span></div>
                        <div>Degeneracy: <span id="degeneracy">-</span></div>
                        <div>Tunneling Prob: <span id="tunnelingProb">-</span>%</div>
                    </div>
                </div>
                <div class="control-group">
                    <div class="tooltip">
                        <label class="control-label">Measurement Strength</label>
                        <span class="tooltiptext">Controls how much measurement disturbs the quantum system. 100% = complete collapse, lower values = partial measurement</span>
                    </div>
                    <div class="slider-container">
                        <input type="range" class="slider" id="measurementStrength" min="0" max="100" value="100">
                        <div class="slider-value" id="measurementStrengthValue">100%</div>
                    </div>
                    <div class="measurement-controls">
                        <button class="measurement-button" id="quantumMeasureButton">Quantum Measure</button>
                        <button class="measurement-button" id="weakMeasureButton">Weak Measure</button>
                        <button class="measurement-button" id="continuousMeasureButton">Continuous</button>
                        <button class="measurement-button" id="decoherenceButton">Decoherence</button>
                    </div>
                </div>
            </div>

            <div class="action-buttons">
                <button class="btn btn-primary" id="analyzeButton">Analyze System</button>
                <button class="btn btn-secondary" id="compareButton">Compare States</button>
            </div>
        </div>

        <!-- Sequencer Tab -->
        <div class="tab-content" id="sequencer">
            <div class="info-panel">
                <strong>Quantum Sequencer:</strong> Generate melodies and rhythms from quantum phenomena like quantum walks, spin chains, tunneling rhythms, and interference beats.
            </div>

            <div class="visualization-container">
                <canvas class="wavefunction-canvas" id="sequencerCanvas"></canvas>
                <div class="controls-grid">
                    <div class="control-group">
                        <div class="tooltip">
                            <label class="control-label">Sequence Type</label>
                            <span class="tooltiptext">Different quantum phenomena generate unique musical patterns: walks create melodies, spins create rhythms, tunneling creates irregular beats</span>
                        </div>
                        <div class="preset-grid" style="margin-bottom: 0;">
                            <div class="preset-btn sequence-type active" data-seq="quantum-walk">Quantum Walk</div>
                            <div class="preset-btn sequence-type" data-seq="spin-chain">Spin Chain</div>
                            <div class="preset-btn sequence-type" data-seq="tunneling">Tunneling Rhythm</div>
                            <div class="preset-btn sequence-type" data-seq="interference">Interference Beat</div>
                        </div>
                    </div>
                    <div class="control-group">
                        <div class="tooltip">
                            <label class="control-label">Sequence Length</label>
                            <span class="tooltiptext">Number of quantum evolution steps to generate. Longer sequences show more complex quantum behavior patterns.</span>
                        </div>
                        <div class="slider-container">
                            <input type="range" class="slider" id="sequenceLength" min="4" max="32" value="16">
                            <div class="slider-value" id="sequenceLengthValue">16</div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="controls-grid">
                <div class="control-group">
                    <div class="tooltip">
                        <label class="control-label">Quantum Parameters</label>
                        <span class="tooltiptext">Core quantum mechanical parameters controlling sequence generation behavior</span>
                    </div>
                    <div class="tooltip">
                        <label class="control-label" style="font-size: 0.8rem;">Walk Probability</label>
                        <span class="tooltiptext">Controls quantum transition probabilities - higher values = bigger jumps between energy states</span>
                        <div class="slider-container">
                            <input type="range" class="slider" id="walkProbability" min="0" max="100" value="50">
                            <div class="slider-value" id="walkProbabilityValue">50%</div>
                        </div>
                    </div>
                    <div class="tooltip">
                        <label class="control-label" style="margin-top: 0.5rem; font-size: 0.8rem;">Evolution Speed</label>
                        <span class="tooltiptext">How fast the quantum system evolves in time - controls tempo of generated patterns</span>
                        <div class="slider-container">
                            <input type="range" class="slider" id="evolutionSpeed" min="100" max="2000" value="500">
                            <div class="slider-value" id="evolutionSpeedValue">500ms</div>
                        </div>
                    </div>
                    <div class="tooltip">
                        <label class="control-label" style="margin-top: 0.5rem; font-size: 0.8rem;">Coherence Time</label>
                        <span class="tooltiptext">How long quantum superposition lasts before decoherence - longer = more predictable patterns</span>
                        <div class="slider-container">
                            <input type="range" class="slider" id="coherenceTime" min="100" max="5000" value="1000">
                            <div class="slider-value" id="coherenceTimeValue">1000ms</div>
                        </div>
                    </div>
                </div>
                <div class="control-group">
                    <label class="control-label">Sequence Control</label>
                    <div class="action-buttons" style="margin-bottom: 0;">
                        <button class="btn btn-primary" id="generateSequence" style="padding: 0.6rem; font-size: 0.9rem;">Generate</button>
                        <button class="btn btn-secondary" id="playSequence" style="padding: 0.6rem; font-size: 0.9rem;">Play</button>
                    </div>
                    <div class="action-buttons" style="margin-top: 0.5rem; margin-bottom: 0;">
                        <button class="btn btn-secondary" id="stopSequence" style="padding: 0.6rem; font-size: 0.9rem;">Stop</button>
                        <button class="btn btn-secondary" id="loopSequence" style="padding: 0.6rem; font-size: 0.9rem;">Loop: Off</button>
                    </div>
                </div>
            </div>

            <div class="visualization-container">
                <div class="control-label">Generated Sequence:</div>
                <div id="sequenceDisplay" style="font-family: monospace; font-size: 0.8rem; line-height: 1.4; background: rgba(0,0,0,0.3); padding: 0.75rem; border-radius: 6px; min-height: 60px; word-break: break-all;">
                    Click "Generate" to create a quantum sequence...
                </div>
                <div id="stepControls" style="margin-top: 1rem; display: none;">
                    <div class="control-label" style="margin-bottom: 0.5rem;">Step-by-Step Control:</div>
                    <div id="sequenceSteps" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(60px, 1fr)); gap: 0.25rem;">
                        <!-- Step controls will be generated here -->
                    </div>
                </div>
            </div>

            <div class="controls-grid">
                <div class="control-group">
                    <div class="tooltip">
                        <label class="control-label">Advanced Parameters</label>
                        <span class="tooltiptext">Temperature affects thermal energy distribution, coupling controls particle interactions</span>
                    </div>
                    <div class="slider-container">
                        <label class="control-label" style="font-size: 0.8rem;">Temperature (K)</label>
                        <input type="range" class="slider" id="temperature" min="0" max="1000" value="300" style="height: 4px;">
                        <div class="slider-value" id="temperatureValue" style="font-size: 0.7rem;">300K</div>
                    </div>
                    <div class="slider-container" style="margin-top: 0.5rem;">
                        <label class="control-label" style="font-size: 0.8rem;">Coupling Strength</label>
                        <input type="range" class="slider" id="couplingStrength" min="0" max="10" value="1" step="0.1" style="height: 4px;">
                        <div class="slider-value" id="couplingStrengthValue" style="font-size: 0.7rem;">1.0</div>
                    </div>
                </div>
                <div class="control-group">
                    <div class="tooltip">
                        <label class="control-label">Advanced Control</label>
                        <span class="tooltiptext">Enhanced sequence generation and integration options</span>
                    </div>
                    <div class="measurement-controls">
                        <button class="measurement-button" id="enableStepControl">Enable Step Control</button>
                        <button class="measurement-button" id="multiParticleMode">Two-Particle Mode</button>
                        <button class="measurement-button" id="synthModulationMode">Synth Modulation</button>
                        <button class="measurement-button" id="testAdvancedParams">Test Parameters</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- About Tab -->
        <div class="tab-content" id="about">
            <div class="info-panel">
                <h3 style="margin-bottom: 1rem; color: #00d4ff;">Dual-Validity Framework</h3>
                <p>This prototype demonstrates how quantum mechanical principles can be translated into sound while maintaining both scientific accuracy and artistic expressiveness.</p>
            </div>

            <div class="info-panel">
                <h4 style="margin-bottom: 0.5rem; color: #9d4edd;">Core Concepts:</h4>
                <ul style="margin-left: 1rem; line-height: 1.6;">
                    <li><strong>Energy Quantization:</strong> Discrete energy levels create specific pitches</li>
                    <li><strong>Wavefunction:</strong> Spatial probability shapes timbre and stereo field</li>
                    <li><strong>Quantum Tunneling:</strong> Probabilistic note transitions</li>
                    <li><strong>Superposition:</strong> Multiple simultaneous states create rich harmonies</li>
                    <li><strong>Measurement Collapse:</strong> Observation changes the quantum state</li>
                    <li><strong>Entanglement:</strong> Correlated particles affect each other instantaneously</li>
                    <li><strong>🆕 Coherence:</strong> Temperature-dependent quantum state stability</li>
                    <li><strong>🆕 Interference:</strong> Wave interference patterns with thermal noise</li>
                    <li><strong>🆕 Phase Transitions:</strong> Critical point phenomena at specific coupling values</li>
                    <li><strong>🆕 Quantum Revival:</strong> Periodic wave packet reconstruction</li>
                </ul>
            </div>

            <div class="info-panel">
                <h4 style="margin-bottom: 0.5rem; color: #9d4edd;">New in v0.2.0:</h4>
                <ul style="margin-left: 1rem; line-height: 1.6;">
                    <li><strong>4 New Quantum Modes:</strong> Coherence, Interference, Phase Transition, Quantum Revival</li>
                    <li><strong>Frequency Mapping System:</strong> 4 strategies to make all energy levels audible</li>
                    <li><strong>Advanced Measurement Tools:</strong> Weak, continuous, and adjustable-strength measurements</li>
                    <li><strong>Enhanced Parameters:</strong> Temperature, coupling strength, coherence time effects</li>
                    <li><strong>Step Control Mode:</strong> Individual control over sequence steps</li>
                    <li><strong>Synthesizer Integration:</strong> Apply quantum modes to sequencer patterns</li>
                </ul>
            </div>

            <div class="info-panel">
                <h4 style="margin-bottom: 0.5rem; color: #9d4edd;">Usage:</h4>
                <p>Adjust the potential well shape by dragging on the visualization. Each configuration generates different energy levels and wavefunctions, resulting in unique sonic signatures that reflect the underlying quantum physics. Use the new frequency mapping modes to ensure all quantum states are audible.</p>
            </div>

            <div class="info-panel" style="border-left-color: #9d4edd; margin-top: 2rem;">
                <div style="font-size: 0.85rem; line-height: 1.5;">
                    <strong>EIGENSOUND LITE v0.2.0</strong><br>
                    Created by <strong>Daniel Sandner</strong> as research experiment<br>
                    for scientific paper project:<br>
                    <em>"Sonification of Quantum Mechanics for Scientific Exploration and Artistic Expression"</em><br><br>
                    Copyright © 2025 Daniel Sandner<br>
                    Research prototype - experimental version
                </div>
            </div>
        </div>
    </div>

    <script>
        class QuantumSonificationApp {
            constructor() {
                this.audioContext = null;
                this.isRecording = false;
                this.recordedChunks = [];
                this.mediaRecorder = null;
                
                // Quantum system parameters
                this.wellWidth = 100;
                this.quantization = 1.0;
                this.decayRate = 200;
                this.synthMode = 0;
                this.potentialShape = 0;
                this.barrierHeight = 5.0;
                this.currentQuantumMode = 'cascade';
                
                // Physics constants (normalized)
                this.hbar = 1;
                this.mass = 1;
                
                // State
                this.energyLevels = [];
                this.wavefunctions = [];
                this.isDecaying = false;
                this.currentPreset = 'particle-box';
                this.isDecoherent = false;
                this.entangledPair = null;
                this.superpositionStates = [];
                
                // Frequency mapping state
                this.baseFrequency = 110;
                this.frequencyMode = 'linear';
                
                // Enhanced measurement state
                this.measurementStrength = 1.0;
                this.isContinuousMeasuring = false;
                this.measurementInterval = null;
                
                // Sequencer state
                this.sequenceType = 'quantum-walk';
                this.sequenceLength = 16;
                this.walkProbability = 0.5;
                this.evolutionSpeed = 500;
                this.coherenceTime = 1000;
                this.currentSequence = [];
                this.isSequencePlaying = false;
                this.sequenceLoop = false;
                this.sequenceInterval = null;
                
                // Advanced parameters
                this.stepControlEnabled = false;
                this.stepExcitations = [];
                this.temperature = 300;
                this.couplingStrength = 1.0;
                this.multiParticleMode = false;
                this.decoherenceTime = 1000;
                this.relaxationTime = 500;
                this.synthModulationEnabled = false;
                
                // Initialize immediately
                this.init();
            }

            init() {
                try {
                    console.log('Initializing Eigensound Lite v0.2.0...');
                    
                    // Initialize physics first - CRITICAL
                    this.calculateInitialPhysics();
                    
                    this.setupEventListeners();
                    this.setupCanvas();
                    this.setQuantumMode('cascade');
                    this.setSequenceType('quantum-walk');
                    this.setFrequencyMode('linear');
                    this.loadPreset('particle-box');
                    
                    console.log('✅ Initialization complete!');
                    console.log('Energy levels:', this.energyLevels.length);
                    
                } catch (error) {
                    console.error('❌ Initialization failed:', error);
                    alert('Failed to initialize Eigensound Lite. Please refresh the page.');
                }
            }

            calculateInitialPhysics() {
                // Force initial physics calculation
                console.log('Calculating initial physics...');
                
                const numLevels = 8;
                const levels = [];
                
                // Use default particle-in-box calculation
                const constant = (Math.PI ** 2 * this.hbar ** 2) / (2 * this.mass * this.wellWidth ** 2);
                for (let n = 1; n <= numLevels; n++) {
                    levels.push(constant * n ** 2);
                }
                
                this.energyLevels = levels;
                this.wavefunctions = this.calculateWavefunctions();
                
                console.log('✅ Initial physics calculated:', this.energyLevels.length, 'energy levels');
                
                // Update displays
                this.updateEnergyLevelDisplay();
                this.updateScientificAnalysis();
            }

            async initAudioContext() {
                if (!this.audioContext) {
                    try {
                        this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                        if (this.audioContext.state === 'suspended') {
                            await this.audioContext.resume();
                        }
                        console.log('✅ Audio context initialized');
                    } catch (error) {
                        console.error('❌ Audio context failed:', error);
                        throw error;
                    }
                }
            }

            setupEventListeners() {
                console.log('Setting up event listeners...');
                
                // Tab switching
                document.querySelectorAll('.tab').forEach(tab => {
                    tab.addEventListener('click', () => this.switchTab(tab.dataset.tab));
                });

                // Parameter controls
                this.setupSliderListener('wellWidth', (val) => {
                    this.wellWidth = parseFloat(val);
                    this.updatePhysics();
                });

                this.setupSliderListener('quantization', (val) => {
                    this.quantization = parseFloat(val) / 100;
                });

                this.setupSliderListener('decayRate', (val) => {
                    this.decayRate = parseFloat(val);
                });

                this.setupSliderListener('synthMode', (val) => {
                    this.synthMode = parseInt(val);
                    const modes = ['Sine', 'Square', 'Sawtooth', 'Triangle'];
                    const display = document.getElementById('synthModeValue');
                    if (display) display.textContent = modes[val];
                });

                this.setupSliderListener('potentialShape', (val) => {
                    this.potentialShape = parseInt(val);
                    const shapes = ['Square Well', 'Harmonic', 'Double Well', 'Step', 'Custom'];
                    const display = document.getElementById('potentialShapeValue');
                    if (display) display.textContent = shapes[val];
                    this.updatePhysics();
                });

                this.setupSliderListener('barrierHeight', (val) => {
                    this.barrierHeight = parseFloat(val);
                    this.updatePhysics();
                });

                this.setupSliderListener('baseFrequency', (val) => {
                    this.baseFrequency = parseFloat(val);
                });

                this.setupSliderListener('measurementStrength', (val) => {
                    this.measurementStrength = parseFloat(val) / 100;
                });

                this.setupSliderListener('sequenceLength', (val) => {
                    this.sequenceLength = parseInt(val);
                    if (this.stepControlEnabled) {
                        this.generateStepControls();
                    }
                    this.generateQuantumSequence();
                });

                this.setupSliderListener('walkProbability', (val) => {
                    this.walkProbability = parseFloat(val) / 100;
                    if (this.currentSequence.length > 0) {
                        this.generateQuantumSequence();
                    }
                });

                this.setupSliderListener('evolutionSpeed', (val) => {
                    this.evolutionSpeed = parseFloat(val);
                });

                this.setupSliderListener('coherenceTime', (val) => {
                    this.coherenceTime = parseFloat(val);
                    if (this.currentSequence.length > 0) {
                        this.generateQuantumSequence();
                    }
                });

                this.setupSliderListener('temperature', (val) => {
                    this.temperature = parseFloat(val);
                });

                this.setupSliderListener('couplingStrength', (val) => {
                    this.couplingStrength = parseFloat(val);
                });

                // Main action buttons
                const exciteButton = document.getElementById('exciteButton');
                if (exciteButton) {
                    exciteButton.addEventListener('click', () => {
                        this.initAudioContext().then(() => this.exciteSystemWithCurrentMode());
                    });
                }

                const recordButton = document.getElementById('recordButton');
                if (recordButton) {
                    recordButton.addEventListener('click', () => {
                        this.toggleRecording();
                    });
                }

                const analyzeButton = document.getElementById('analyzeButton');
                if (analyzeButton) {
                    analyzeButton.addEventListener('click', () => {
                        this.analyzeSystem();
                    });
                }

                const compareButton = document.getElementById('compareButton');
                if (compareButton) {
                    compareButton.addEventListener('click', () => {
                        this.compareStates();
                    });
                }

                // Preset buttons
                document.querySelectorAll('.preset-btn[data-preset]').forEach(btn => {
                    btn.addEventListener('click', () => this.loadPreset(btn.dataset.preset));
                });

                // Quantum mode buttons
                document.querySelectorAll('.quantum-mode').forEach(btn => {
                    btn.addEventListener('click', () => {
                        this.setQuantumMode(btn.dataset.mode);
                    });
                });

                // Frequency mode buttons
                document.querySelectorAll('.frequency-mode').forEach(btn => {
                    btn.addEventListener('click', () => {
                        this.setFrequencyMode(btn.dataset.freq);
                    });
                });

                // Sequence type buttons
                document.querySelectorAll('.sequence-type').forEach(btn => {
                    btn.addEventListener('click', () => this.setSequenceType(btn.dataset.seq));
                });

                // Measurement buttons
                const measureButtons = [
                    ['quantumMeasureButton', () => this.performQuantumMeasurement()],
                    ['weakMeasureButton', () => this.performWeakMeasurement()],
                    ['continuousMeasureButton', () => this.toggleContinuousMeasurement()],
                    ['decoherenceButton', () => this.simulateDecoherence()]
                ];

                measureButtons.forEach(([id, handler]) => {
                    const button = document.getElementById(id);
                    if (button) {
                        button.addEventListener('click', handler);
                    }
                });

                // Sequencer controls
                const sequencerButtons = [
                    ['generateSequence', () => this.generateQuantumSequence()],
                    ['playSequence', () => this.initAudioContext().then(() => this.playQuantumSequence())],
                    ['stopSequence', () => this.stopQuantumSequence()],
                    ['loopSequence', () => this.toggleSequenceLoop()]
                ];

                sequencerButtons.forEach(([id, handler]) => {
                    const button = document.getElementById(id);
                    if (button) {
                        button.addEventListener('click', handler);
                    }
                });

                // Advanced controls
                const advancedButtons = [
                    ['enableStepControl', () => this.toggleStepControl()],
                    ['multiParticleMode', () => this.toggleMultiParticleMode()],
                    ['synthModulationMode', () => this.toggleSynthModulation()],
                    ['testAdvancedParams', () => this.testAdvancedParameters()]
                ];

                advancedButtons.forEach(([id, handler]) => {
                    const button = document.getElementById(id);
                    if (button) {
                        button.addEventListener('click', handler);
                    }
                });

                // Profile management
                const saveButton = document.getElementById('saveProfile');
                if (saveButton) {
                    saveButton.addEventListener('click', () => this.saveProfile());
                }

                const loadButton = document.getElementById('loadProfile');
                if (loadButton) {
                    loadButton.addEventListener('click', () => {
                        document.getElementById('fileInput').click();
                    });
                }

                const fileInput = document.getElementById('fileInput');
                if (fileInput) {
                    fileInput.addEventListener('change', (e) => {
                        this.loadProfileFromFile(e.target.files[0]);
                    });
                }

                // Canvas interaction
                const canvas = document.getElementById('wavefunctionCanvas');
                if (canvas) {
                    let isDrawing = false;
                    
                    const handlePointerStart = (e) => {
                        isDrawing = true;
                        this.editPotentialWell(e);
                    };
                    
                    const handlePointerMove = (e) => {
                        if (isDrawing) {
                            this.editPotentialWell(e);
                        }
                    };
                    
                    const handlePointerEnd = () => {
                        isDrawing = false;
                        this.updatePhysics();
                    };

                    canvas.addEventListener('pointerdown', handlePointerStart);
                    canvas.addEventListener('pointermove', handlePointerMove);
                    canvas.addEventListener('pointerup', handlePointerEnd);
                    canvas.addEventListener('pointerleave', handlePointerEnd);
                }

                console.log('✅ Event listeners setup complete');
            }

            setupSliderListener(id, callback) {
                const slider = document.getElementById(id);
                const valueDisplay = document.getElementById(id + 'Value');
                
                if (!slider) {
                    if (id !== 'measurementStrength') {
                        console.warn(`Slider element with id '${id}' not found`);
                    }
                    return;
                }
                
                slider.addEventListener('input', (e) => {
                    const value = e.target.value;
                    callback(value);
                    
                    if (valueDisplay) {
                        if (id === 'quantization' || id === 'walkProbability' || id === 'measurementStrength') {
                            valueDisplay.textContent = value + '%';
                        } else if (id === 'decayRate' || id === 'evolutionSpeed' || id === 'coherenceTime') {
                            valueDisplay.textContent = value + 'ms';
                        } else if (id === 'temperature') {
                            valueDisplay.textContent = value + 'K';
                        } else {
                            valueDisplay.textContent = value;
                        }
                    }
                });
            }

            switchTab(tabName) {
                document.querySelectorAll('.tab').forEach(tab => {
                    tab.classList.toggle('active', tab.dataset.tab === tabName);
                });

                document.querySelectorAll('.tab-content').forEach(content => {
                    content.classList.toggle('active', content.id === tabName);
                });
                
                setTimeout(() => {
                    this.setupCanvas();
                    this.drawVisualization();
                }, 100);
            }

            setupCanvas() {
                const canvases = [
                    document.getElementById('wavefunctionCanvas'),
                    document.getElementById('explorerCanvas'),
                    document.getElementById('sequencerCanvas')
                ];
                
                canvases.forEach(canvas => {
                    if (canvas) {
                        canvas.width = canvas.offsetWidth * window.devicePixelRatio;
                        canvas.height = canvas.offsetHeight * window.devicePixelRatio;
                        const ctx = canvas.getContext('2d');
                        ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
                    }
                });
            }

            // FIXED: Complete frequency mapping implementation
            energyToFrequency(energy) {
                if (!this.energyLevels || this.energyLevels.length === 0) {
                    console.warn('No energy levels available for frequency mapping');
                    return this.baseFrequency;
                }
                
                const baseFreq = this.baseFrequency;
                const minEnergy = Math.min(...this.energyLevels);
                const maxEnergy = Math.max(...this.energyLevels);
                
                switch (this.frequencyMode) {
                    case 'linear':
                        return baseFreq * (energy / this.energyLevels[0]);
                        
                    case 'log':
                        const ratio = energy / this.energyLevels[0];
                        return baseFreq * Math.pow(2, Math.log2(Math.max(ratio, 0.1)));
                        
                    case 'octave':
                        const normalizedEnergy = (energy - minEnergy) / (maxEnergy - minEnergy);
                        return baseFreq * Math.pow(2, normalizedEnergy);
                        
                    case 'normalize':
                        const freqSpan = baseFreq * 3;
                        return baseFreq + (energy - minEnergy) / (maxEnergy - minEnergy) * freqSpan;
                        
                    default:
                        return baseFreq * (energy / this.energyLevels[0]);
                }
            }

            setFrequencyMode(mode) {
                this.frequencyMode = mode;
                
                document.querySelectorAll('.frequency-mode').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.freq === mode);
                });
                
                console.log(`Frequency mode set to: ${mode}`);
            }

            setQuantumMode(mode) {
                this.currentQuantumMode = mode;
                
                document.querySelectorAll('.quantum-mode').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.mode === mode);
                });
                
                console.log(`Quantum mode set to: ${mode}`);
            }

            setSequenceType(type) {
                this.sequenceType = type;
                
                document.querySelectorAll('.sequence-type').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.seq === type);
                });
                
                this.generateQuantumSequence();
            }

            calculateEnergyLevels() {
                const numLevels = 8;
                const levels = [];
                
                try {
                    if (this.potentialShape === 0) { // Square well
                        const constant = (Math.PI ** 2 * this.hbar ** 2) / (2 * this.mass * this.wellWidth ** 2);
                        for (let n = 1; n <= numLevels; n++) {
                            levels.push(constant * n ** 2);
                        }
                    } else if (this.potentialShape === 1) { // Harmonic oscillator
                        const omega = 2 * Math.PI / this.wellWidth;
                        for (let n = 0; n < numLevels; n++) {
                            levels.push(this.hbar * omega * (n + 0.5));
                        }
                    } else if (this.potentialShape === 2) { // Double well
                        const constant = (Math.PI ** 2 * this.hbar ** 2) / (2 * this.mass * (this.wellWidth/2) ** 2);
                        for (let n = 1; n <= numLevels; n++) {
                            const baseLevel = constant * n ** 2;
                            levels.push(baseLevel);
                            if (n <= 4) {
                                const splitting = baseLevel * 0.1 * Math.exp(-this.barrierHeight);
                                levels.push(baseLevel + splitting);
                            }
                        }
                    } else { // Default to particle in box
                        const constant = (Math.PI ** 2 * this.hbar ** 2) / (2 * this.mass * this.wellWidth ** 2);
                        for (let n = 1; n <= numLevels; n++) {
                            levels.push(constant * n ** 2);
                        }
                    }
                    
                    const result = levels.slice(0, numLevels);
                    console.log('✅ Energy levels calculated:', result.length);
                    return result;
                    
                } catch (error) {
                    console.error('❌ Energy level calculation failed:', error);
                    // Return default levels
                    const constant = (Math.PI ** 2 * this.hbar ** 2) / (2 * this.mass * 100 ** 2);
                    for (let n = 1; n <= numLevels; n++) {
                        levels.push(constant * n ** 2);
                    }
                    return levels;
                }
            }

            calculateWavefunctions() {
                const functions = [];
                const points = 200;
                
                try {
                    for (let i = 0; i < this.energyLevels.length; i++) {
                        const wavefunction = [];
                        const n = i + 1;
                        
                        for (let x = 0; x < points; x++) {
                            const normalizedX = (x / points) * this.wellWidth;
                            let amplitude;
                            
                            if (this.potentialShape === 0) {
                                amplitude = Math.sqrt(2 / this.wellWidth) * 
                                           Math.sin(n * Math.PI * normalizedX / this.wellWidth);
                            } else if (this.potentialShape === 1) {
                                const xi = normalizedX - this.wellWidth / 2;
                                amplitude = Math.exp(-xi * xi / (this.wellWidth / 4)) * 
                                           Math.sin(n * Math.PI * normalizedX / this.wellWidth);
                            } else {
                                amplitude = Math.sqrt(2 / this.wellWidth) * 
                                           Math.sin(n * Math.PI * normalizedX / this.wellWidth);
                            }
                            
                            wavefunction.push(amplitude);
                        }
                        functions.push(wavefunction);
                    }
                    
                    console.log('✅ Wavefunctions calculated:', functions.length);
                    return functions;
                    
                } catch (error) {
                    console.error('❌ Wavefunction calculation failed:', error);
                    return [];
                }
            }

            updatePhysics() {
                try {
                    console.log('Updating physics...');
                    this.energyLevels = this.calculateEnergyLevels();
                    this.wavefunctions = this.calculateWavefunctions();
                    this.updateEnergyLevelDisplay();
                    this.updateScientificAnalysis();
                    this.drawVisualization();
                    console.log('✅ Physics updated');
                } catch (error) {
                    console.error('❌ Physics update failed:', error);
                }
            }

            updateEnergyLevelDisplay() {
                const container = document.getElementById('energyLevels');
                if (!container) return;
                
                container.innerHTML = '';
                
                if (this.energyLevels.length === 0) {
                    container.innerHTML = '<div style="color: #ff4757;">No energy levels calculated</div>';
                    return;
                }
                
                this.energyLevels.forEach((energy, index) => {
                    const levelEl = document.createElement('div');
                    levelEl.className = 'energy-level';
                    levelEl.textContent = `E${index + 1}: ${energy.toFixed(2)}`;
                    levelEl.addEventListener('click', () => this.playLevel(index));
                    container.appendChild(levelEl);
                });
            }

            updateScientificAnalysis() {
                const analysisContainer = document.getElementById('analysisResults');
                if (!analysisContainer) return;
                
                if (this.energyLevels.length === 0) {
                    // Update with placeholder values
                    const elements = {
                        'energyCount': 0,
                        'avgSpacing': '0',
                        'maxQuantum': 0,
                        'degeneracy': 0,
                        'tunnelingProb': '0.00'
                    };
                    
                    Object.entries(elements).forEach(([id, value]) => {
                        const element = document.getElementById(id);
                        if (element) {
                            element.textContent = value;
                        }
                    });
                    return;
                }
                
                const energySpacing = [];
                for (let i = 1; i < this.energyLevels.length; i++) {
                    energySpacing.push(this.energyLevels[i] - this.energyLevels[i-1]);
                }
                
                const avgSpacing = energySpacing.length > 0 ? 
                    (energySpacing.reduce((a,b) => a+b, 0) / energySpacing.length).toFixed(3) : '0';
                
                const degeneracy = this.calculateDegeneracy();
                const tunnelingProb = this.calculateTunnelingProbability();
                
                const elements = {
                    'energyCount': this.energyLevels.length,
                    'avgSpacing': avgSpacing,
                    'maxQuantum': this.energyLevels.length,
                    'degeneracy': degeneracy,
                    'tunnelingProb': tunnelingProb.toFixed(2)
                };
                
                Object.entries(elements).forEach(([id, value]) => {
                    const element = document.getElementById(id);
                    if (element) {
                        element.textContent = value;
                    }
                });
            }

            calculateDegeneracy() {
                const uniqueEnergies = [...new Set(this.energyLevels.map(e => Math.round(e * 100) / 100))];
                return this.energyLevels.length - uniqueEnergies.length;
            }

            calculateTunnelingProbability() {
                if (this.potentialShape === 0 || this.potentialShape === 2) {
                    const energy = this.energyLevels[0];
                    if (energy < this.barrierHeight) {
                        const penetrationFactor = Math.sqrt(2 * this.mass * (this.barrierHeight - energy));
                        const transmission = Math.exp(-2 * penetrationFactor * (this.wellWidth / 20));
                        return Math.min(100, transmission * 100);
                    }
                }
                return 0;
            }

            drawVisualization() {
                const activeTab = document.querySelector('.tab-content.active');
                if (!activeTab) return;
                
                let canvas;
                if (activeTab.id === 'explorer') {
                    canvas = document.getElementById('explorerCanvas');
                } else if (activeTab.id === 'sequencer') {
                    canvas = document.getElementById('sequencerCanvas');
                } else {
                    canvas = document.getElementById('wavefunctionCanvas');
                }
                
                if (!canvas) return;
                
                const ctx = canvas.getContext('2d');
                const width = canvas.offsetWidth;
                const height = canvas.offsetHeight;
                
                ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                ctx.fillRect(0, 0, width, height);
                
                if (activeTab.id === 'sequencer') {
                    this.drawSequencerVisualization(ctx, width, height);
                } else {
                    this.drawPotentialWell(ctx, width, height);
                    this.drawWavefunctions(ctx, width, height);
                    this.drawEnergyLevels(ctx, width, height);
                }
            }

            drawPotentialWell(ctx, width, height) {
                ctx.strokeStyle = 'rgba(0, 212, 255, 0.5)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                const wellHeight = height * 0.7;
                const wellStart = width * 0.1;
                const wellEnd = width * 0.9;
                const barrierHeightPx = (this.barrierHeight / 10) * wellHeight * 0.8;
                
                if (this.potentialShape === 0) {
                    ctx.moveTo(0, barrierHeightPx);
                    ctx.lineTo(wellStart, barrierHeightPx);
                    ctx.lineTo(wellStart, wellHeight);
                    ctx.lineTo(wellEnd, wellHeight);
                    ctx.lineTo(wellEnd, barrierHeightPx);
                    ctx.lineTo(width, barrierHeightPx);
                    
                    ctx.fillStyle = 'rgba(255, 71, 87, 0.2)';
                    ctx.fillRect(0, 0, wellStart, barrierHeightPx);
                    ctx.fillRect(wellEnd, 0, width - wellEnd, barrierHeightPx);
                    
                } else if (this.potentialShape === 1) {
                    for (let x = 0; x < width; x++) {
                        const normalizedX = (x - width/2) / (width/4);
                        const y = wellHeight - (normalizedX * normalizedX * wellHeight / 4) + barrierHeightPx;
                        if (x === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                } else if (this.potentialShape === 2) {
                    const center = width / 2;
                    const barrierWidth = width * 0.05;
                    ctx.moveTo(0, barrierHeightPx);
                    ctx.lineTo(wellStart, barrierHeightPx);
                    ctx.lineTo(wellStart, wellHeight);
                    ctx.lineTo(center - barrierWidth, wellHeight);
                    ctx.lineTo(center - barrierWidth, wellHeight - barrierHeightPx);
                    ctx.lineTo(center + barrierWidth, wellHeight - barrierHeightPx);
                    ctx.lineTo(center + barrierWidth, wellHeight);
                    ctx.lineTo(wellEnd, wellHeight);
                    ctx.lineTo(wellEnd, barrierHeightPx);
                    ctx.lineTo(width, barrierHeightPx);
                    
                    ctx.fillStyle = 'rgba(255, 71, 87, 0.3)';
                    ctx.fillRect(center - barrierWidth, wellHeight - barrierHeightPx, 
                                barrierWidth * 2, barrierHeightPx);
                }
                
                ctx.stroke();
                
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.font = '12px monospace';
                ctx.fillText(`Barrier: ${this.barrierHeight.toFixed(1)}`, width * 0.02, 20);
            }

            drawWavefunctions(ctx, width, height) {
                if (this.wavefunctions.length === 0) return;
                
                const colors = [
                    'rgba(255, 71, 87, 0.8)',
                    'rgba(0, 212, 255, 0.8)',
                    'rgba(157, 78, 221, 0.8)',
                    'rgba(255, 184, 0, 0.8)',
                    'rgba(46, 213, 115, 0.8)',
                    'rgba(255, 118, 117, 0.8)',
                    'rgba(116, 185, 255, 0.8)',
                    'rgba(162, 155, 254, 0.8)'
                ];
                
                this.wavefunctions.forEach((wavefunction, index) => {
                    if (index >= 3) return;
                    
                    ctx.strokeStyle = colors[index];
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    
                    const centerY = height * (0.8 - index * 0.15);
                    const amplitude = height * 0.05;
                    
                    wavefunction.forEach((value, i) => {
                        const x = (i / wavefunction.length) * width * 0.8 + width * 0.1;
                        const y = centerY - value * amplitude;
                        
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    });
                    
                    ctx.stroke();
                });
            }

            drawEnergyLevels(ctx, width, height) {
                if (this.energyLevels.length === 0) return;
                
                const maxEnergy = Math.max(...this.energyLevels);
                
                this.energyLevels.forEach((energy, index) => {
                    const y = height - (energy / maxEnergy) * height * 0.8;
                    
                    ctx.strokeStyle = `rgba(0, 212, 255, ${0.3 + index * 0.1})`;
                    ctx.lineWidth = 1;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.moveTo(width * 0.05, y);
                    ctx.lineTo(width * 0.95, y);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    
                    ctx.fillStyle = 'rgba(0, 212, 255, 0.8)';
                    ctx.font = '10px monospace';
                    ctx.fillText(`n=${index + 1}`, width * 0.02, y - 2);
                });
            }

            drawSequencerVisualization(ctx, width, height) {
                if (this.currentSequence.length === 0) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                    ctx.font = '16px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('Generate a sequence to see visualization', width / 2, height / 2);
                    return;
                }
                
                const stepWidth = width / this.currentSequence.length;
                const maxEnergy = Math.max(...this.energyLevels);
                
                this.currentSequence.forEach((step, i) => {
                    const x = i * stepWidth;
                    const energy = step.energyLevel >= 0 ? this.energyLevels[step.energyLevel] : 0;
                    const barHeight = (energy / maxEnergy) * height * 0.8;
                    
                    let color = '#00d4ff';
                    
                    ctx.fillStyle = color;
                    ctx.fillRect(x, height - barHeight, stepWidth - 1, barHeight);
                    
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.font = '10px monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText((i + 1).toString(), x + stepWidth / 2, height - 5);
                });
            }

            editPotentialWell(e) {
                const canvas = document.getElementById('wavefunctionCanvas');
                if (!canvas) return;
                
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                
                const newWidth = Math.max(20, Math.min(200, (x / rect.width) * 180 + 20));
                this.wellWidth = newWidth;
                
                const slider = document.getElementById('wellWidth');
                const display = document.getElementById('wellWidthValue');
                
                if (slider) slider.value = newWidth;
                if (display) display.textContent = newWidth.toFixed(0);
                
                this.updatePhysics();
            }

            createOscillator(frequency, type = 'sine') {
                const osc = this.audioContext.createOscillator();
                const gain = this.audioContext.createGain();
                
                const types = ['sine', 'square', 'sawtooth', 'triangle'];
                osc.type = types[this.synthMode] || type;
                
                const uncertainty = (1 - this.quantization) * 0.05;
                const detuneAmount = (Math.random() - 0.5) * uncertainty * 100;
                osc.detune.setValueAtTime(detuneAmount, this.audioContext.currentTime);
                
                osc.frequency.setValueAtTime(frequency, this.audioContext.currentTime);
                
                osc.connect(gain);
                gain.connect(this.audioContext.destination);
                
                return { osc, gain };
            }

            async playLevel(levelIndex) {
                if (!this.audioContext) {
                    await this.initAudioContext();
                }
                
                if (levelIndex >= this.energyLevels.length) {
                    console.warn('Invalid level index:', levelIndex);
                    return;
                }
                
                const energy = this.energyLevels[levelIndex];
                const frequency = this.energyToFrequency(energy);
                const { osc, gain } = this.createOscillator(frequency);
                
                gain.gain.setValueAtTime(0.3, this.audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 1);
                
                osc.start(this.audioContext.currentTime);
                osc.stop(this.audioContext.currentTime + 1.2);
                
                this.animateParticle(levelIndex);
                this.highlightEnergyLevel(levelIndex);
            }

            animateParticle(levelIndex) {
                const container = document.getElementById('particleContainer');
                if (!container) return;
                
                const particle = document.createElement('div');
                particle.className = 'quantum-particle';
                
                const maxEnergy = Math.max(...this.energyLevels);
                const energy = this.energyLevels[levelIndex];
                const yPosition = (1 - energy / maxEnergy) * 80;
                
                particle.style.bottom = `${yPosition}%`;
                particle.style.left = `${Math.random() * 90}%`;
                particle.style.opacity = '1';
                
                container.appendChild(particle);
                
                setTimeout(() => {
                    particle.style.opacity = '0';
                    setTimeout(() => {
                        if (particle.parentNode) {
                            particle.parentNode.removeChild(particle);
                        }
                    }, 300);
                }, 800);
            }

            highlightEnergyLevel(levelIndex) {
                const levels = document.querySelectorAll('.energy-level');
                if (levels[levelIndex]) {
                    levels[levelIndex].classList.add('playing');
                    setTimeout(() => {
                        levels[levelIndex].classList.remove('playing');
                    }, 1000);
                }
            }

            async exciteSystemWithCurrentMode() {
                if (this.isDecaying) return;
                
                switch (this.currentQuantumMode) {
                    case 'cascade':
                        return this.exciteSystem();
                    case 'superposition':
                        return this.playSuperposition();
                    case 'entanglement':
                        return this.playEntangledStates();
                    case 'tunneling':
                        return this.playTunnelingBeats();
                    case 'coherence':
                        return this.playCoherenceMode();
                    case 'interference':
                        return this.playInterferenceMode();
                    case 'phase-transition':
                        return this.playPhaseTransition();
                    case 'revival':
                        return this.playQuantumRevival();
                    default:
                        return this.exciteSystem();
                }
            }

            async exciteSystem() {
                if (this.isDecaying) return;
                this.isDecaying = true;
                
                // Play excitation sound
                const { osc: exciteOsc, gain: exciteGain } = this.createOscillator(1000, 'sawtooth');
                exciteOsc.frequency.exponentialRampToValueAtTime(200, this.audioContext.currentTime + 0.1);
                exciteGain.gain.setValueAtTime(0.2, this.audioContext.currentTime);
                exciteGain.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 0.1);
                exciteOsc.start(this.audioContext.currentTime);
                exciteOsc.stop(this.audioContext.currentTime + 0.15);
                
                // Decay cascade
                let currentLevel = this.energyLevels.length - 1;
                
                const decay = () => {
                    if (currentLevel < 0) {
                        this.isDecaying = false;
                        return;
                    }
                    
                    this.playLevel(currentLevel);
                    
                    const jumpSize = Math.random() < 0.7 ? 1 : Math.floor(Math.random() * 3) + 1;
                    currentLevel -= jumpSize;
                    
                    if (currentLevel >= 0) {
                        setTimeout(decay, this.decayRate);
                    } else {
                        this.isDecaying = false;
                    }
                };
                
                setTimeout(decay, 100);
            }

            async playSuperposition() {
                if (!this.audioContext) await this.initAudioContext();
                
                const numStates = Math.min(4, this.energyLevels.length);
                const activeStates = [];
                
                for (let i = 0; i < numStates; i++) {
                    const levelIndex = Math.floor(Math.random() * this.energyLevels.length);
                    const energy = this.energyLevels[levelIndex];
                    const frequency = this.energyToFrequency(energy);
                    
                    const { osc, gain } = this.createOscillator(frequency);
                    const amplitude = 0.15 / numStates;
                    
                    gain.gain.setValueAtTime(amplitude, this.audioContext.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 2);
                    
                    osc.start(this.audioContext.currentTime);
                    osc.stop(this.audioContext.currentTime + 2.2);
                    
                    activeStates.push(levelIndex);
                    this.animateParticle(levelIndex);
                }
                
                this.superpositionStates = activeStates;
            }

            async playEntangledStates() {
                if (!this.audioContext) await this.initAudioContext();
                
                const level1 = Math.floor(this.energyLevels.length / 3);
                const level2 = this.energyLevels.length - 1 - level1;
                
                const freq1 = this.energyToFrequency(this.energyLevels[level1]);
                const freq2 = this.energyToFrequency(this.energyLevels[level2]);
                
                const { osc: osc1, gain: gain1 } = this.createOscillator(freq1);
                const { osc: osc2, gain: gain2 } = this.createOscillator(freq2);
                
                gain1.gain.setValueAtTime(0.2, this.audioContext.currentTime);
                gain2.gain.setValueAtTime(0.1, this.audioContext.currentTime);
                
                const lfo = this.audioContext.createOscillator();
                const lfoGain = this.audioContext.createGain();
                lfo.frequency.setValueAtTime(0.5, this.audioContext.currentTime);
                lfoGain.gain.setValueAtTime(10, this.audioContext.currentTime);
                
                lfo.connect(lfoGain);
                lfoGain.connect(osc1.detune);
                lfoGain.connect(osc2.detune);
                
                osc1.start(this.audioContext.currentTime);
                osc2.start(this.audioContext.currentTime);
                lfo.start(this.audioContext.currentTime);
                
                osc1.stop(this.audioContext.currentTime + 3);
                osc2.stop(this.audioContext.currentTime + 3);
                lfo.stop(this.audioContext.currentTime + 3);
                
                gain1.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 3);
                gain2.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 3);
                
                this.animateParticle(level1);
                this.animateParticle(level2);
            }

            async playTunnelingBeats() {
                if (!this.audioContext) await this.initAudioContext();
                
                const level1 = 2;
                const level2 = 3;
                
                if (level2 >= this.energyLevels.length) return;
                
                const freq1 = this.energyToFrequency(this.energyLevels[level1]);
                const freq2 = freq1 * 1.02;
                
                const { osc: osc1, gain: gain1 } = this.createOscillator(freq1);
                const { osc: osc2, gain: gain2 } = this.createOscillator(freq2);
                
                gain1.gain.setValueAtTime(0.15, this.audioContext.currentTime);
                gain2.gain.setValueAtTime(0.15, this.audioContext.currentTime);
                
                const tremolo = this.audioContext.createOscillator();
                const tremoloGain = this.audioContext.createGain();
                tremolo.frequency.setValueAtTime(Math.abs(freq2 - freq1), this.audioContext.currentTime);
                tremoloGain.gain.setValueAtTime(0.1, this.audioContext.currentTime);
                
                tremolo.connect(tremoloGain);
                tremoloGain.connect(gain1.gain);
                tremoloGain.connect(gain2.gain);
                
                osc1.start(this.audioContext.currentTime);
                osc2.start(this.audioContext.currentTime);
                tremolo.start(this.audioContext.currentTime);
                
                const duration = 4;
                osc1.stop(this.audioContext.currentTime + duration);
                osc2.stop(this.audioContext.currentTime + duration);
                tremolo.stop(this.audioContext.currentTime + duration);
                
                gain1.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + duration);
                gain2.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + duration);
            }

            // NEW QUANTUM MODES
            async playCoherenceMode() {
                if (!this.audioContext) await this.initAudioContext();
                
                const numStates = 3;
                
                for (let i = 0; i < numStates; i++) {
                    const levelIndex = i + 1;
                    if (levelIndex >= this.energyLevels.length) continue;
                    
                    const energy = this.energyLevels[levelIndex];
                    const frequency = this.energyToFrequency(energy);
                    
                    const { osc, gain } = this.createOscillator(frequency);
                    
                    gain.gain.setValueAtTime(0.2, this.audioContext.currentTime);
                    
                    const decoherenceRate = this.temperature / 1000;
                    
                    for (let t = 0; t < 3; t += 0.1) {
                        const coherenceFactor = Math.exp(-decoherenceRate * t);
                        const noiseAmount = (1 - coherenceFactor) * 20;
                        
                        osc.detune.setValueAtTime(
                            (Math.random() - 0.5) * noiseAmount,
                            this.audioContext.currentTime + t
                        );
                    }
                    
                    osc.start(this.audioContext.currentTime);
                    osc.stop(this.audioContext.currentTime + 3);
                    
                    gain.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 3);
                    
                    this.animateParticle(levelIndex);
                }
            }

            async playInterferenceMode() {
                if (!this.audioContext) await this.initAudioContext();
                
                const level1 = 2;
                const level2 = 3;
                
                if (level2 >= this.energyLevels.length) return;
                
                const freq1 = this.energyToFrequency(this.energyLevels[level1]);
                const freq2 = freq1 * (1 + this.couplingStrength * 0.01);
                
                const { osc: osc1, gain: gain1 } = this.createOscillator(freq1);
                const { osc: osc2, gain: gain2 } = this.createOscillator(freq2);
                
                gain1.gain.setValueAtTime(0.15, this.audioContext.currentTime);
                gain2.gain.setValueAtTime(0.15, this.audioContext.currentTime);
                
                const thermalModulation = this.audioContext.createOscillator();
                const thermalGain = this.audioContext.createGain();
                thermalModulation.frequency.setValueAtTime(this.temperature / 100, this.audioContext.currentTime);
                thermalGain.gain.setValueAtTime(0.05, this.audioContext.currentTime);
                
                thermalModulation.connect(thermalGain);
                thermalGain.connect(gain1.gain);
                thermalGain.connect(gain2.gain);
                
                osc1.start(this.audioContext.currentTime);
                osc2.start(this.audioContext.currentTime);
                thermalModulation.start(this.audioContext.currentTime);
                
                const duration = 4;
                osc1.stop(this.audioContext.currentTime + duration);
                osc2.stop(this.audioContext.currentTime + duration);
                thermalModulation.stop(this.audioContext.currentTime + duration);
                
                gain1.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + duration);
                gain2.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + duration);
                
                console.log(`Interference mode: thermal modulation = ${this.temperature/100} Hz`);
            }

            async playPhaseTransition() {
                if (!this.audioContext) await this.initAudioContext();
                
                const criticalCoupling = 5.0;
                const transitionSharpness = Math.abs(this.couplingStrength - criticalCoupling);
                
                if (transitionSharpness < 1.0) {
                    const numOscillators = 5;
                    for (let i = 0; i < numOscillators; i++) {
                        const levelIndex = Math.floor(Math.random() * this.energyLevels.length);
                        const energy = this.energyLevels[levelIndex];
                        const frequency = this.energyToFrequency(energy);
                        
                        const { osc, gain } = this.createOscillator(frequency);
                        
                        const fluctuationRate = 10 + Math.random() * 20;
                        const fluctuationDepth = 50 * (1 - transitionSharpness);
                        
                        osc.detune.setValueAtTime(0, this.audioContext.currentTime);
                        for (let t = 0; t < 2; t += 0.05) {
                            const detune = Math.sin(fluctuationRate * t) * fluctuationDepth;
                            osc.detune.setValueAtTime(detune, this.audioContext.currentTime + t);
                        }
                        
                        gain.gain.setValueAtTime(0.1, this.audioContext.currentTime);
                        gain.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 2);
                        
                        osc.start(this.audioContext.currentTime + i * 0.1);
                        osc.stop(this.audioContext.currentTime + 2.2);
                        
                        this.animateParticle(levelIndex);
                    }
                } else {
                    this.exciteSystem();
                }
                
                console.log(`Phase transition mode: coupling = ${this.couplingStrength}, critical distance = ${transitionSharpness.toFixed(2)}`);
            }

            async playQuantumRevival() {
                if (!this.audioContext) await this.initAudioContext();
                
                const revivalTime = 2.0;
                const fundamentalFreq = this.energyToFrequency(this.energyLevels[0]);
                
                const components = [1, 2, 3, 4, 5];
                
                components.forEach((n, index) => {
                    const frequency = fundamentalFreq * n;
                    const { osc, gain } = this.createOscillator(frequency);
                    
                    for (let t = 0; t < revivalTime; t += 0.1) {
                        const revivalFactor = Math.abs(Math.cos(Math.PI * t / revivalTime));
                        const amplitude = 0.15 * revivalFactor / components.length;
                        gain.gain.setValueAtTime(amplitude, this.audioContext.currentTime + t);
                    }
                    
                    osc.start(this.audioContext.currentTime + index * 0.05);
                    osc.stop(this.audioContext.currentTime + revivalTime + 0.1);
                    
                    this.animateParticle(Math.min(index, this.energyLevels.length - 1));
                });
                
                console.log(`Quantum revival: revival time = ${revivalTime}s, components = ${components.length}`);
            }

            // MEASUREMENT FUNCTIONS
            performQuantumMeasurement() {
                if (this.superpositionStates.length > 0) {
                    const collapsedState = this.superpositionStates[
                        Math.floor(Math.random() * this.superpositionStates.length)
                    ];
                    this.playLevel(collapsedState);
                    this.superpositionStates = [collapsedState];
                    
                    console.log(`Quantum measurement collapsed superposition to state n=${collapsedState + 1}`);
                } else {
                    const randomState = Math.floor(Math.random() * this.energyLevels.length);
                    this.playLevel(randomState);
                    console.log(`Measured quantum state: n=${randomState + 1}, E=${this.energyLevels[randomState].toFixed(3)}`);
                }
            }

            async performWeakMeasurement() {
                if (this.superpositionStates.length > 0 && this.measurementStrength < 1.0) {
                    const partialCollapse = Math.random() < this.measurementStrength;
                    if (partialCollapse) {
                        const measuredState = this.superpositionStates[
                            Math.floor(Math.random() * this.superpositionStates.length)
                        ];
                        this.playWeakMeasurementSound(measuredState);
                    }
                } else {
                    this.performQuantumMeasurement();
                }
            }

            async playWeakMeasurementSound(stateIndex) {
                if (!this.audioContext) await this.initAudioContext();
                
                const energy = this.energyLevels[stateIndex];
                const frequency = this.energyToFrequency(energy);
                const { osc, gain } = this.createOscillator(frequency);
                
                const amplitude = 0.1 * this.measurementStrength;
                
                gain.gain.setValueAtTime(amplitude, this.audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 0.5);
                
                osc.start(this.audioContext.currentTime);
                osc.stop(this.audioContext.currentTime + 0.6);
                
                this.animateParticle(stateIndex);
            }

            toggleContinuousMeasurement() {
                this.isContinuousMeasuring = !this.isContinuousMeasuring;
                const button = document.getElementById('continuousMeasureButton');
                
                if (this.isContinuousMeasuring) {
                    button.classList.add('active');
                    button.textContent = 'Stop Continuous';
                    this.startContinuousMeasurement();
                } else {
                    button.classList.remove('active');
                    button.textContent = 'Continuous';
                    this.stopContinuousMeasurement();
                }
            }

            startContinuousMeasurement() {
                this.measurementInterval = setInterval(() => {
                    if (Math.random() < 0.3) {
                        this.performWeakMeasurement();
                    }
                }, 500);
            }

            stopContinuousMeasurement() {
                if (this.measurementInterval) {
                    clearInterval(this.measurementInterval);
                    this.measurementInterval = null;
                }
            }

            simulateDecoherence() {
                this.isDecoherent = !this.isDecoherent;
                const button = document.getElementById('decoherenceButton');
                
                if (this.isDecoherent) {
                    this.quantization = 0.3;
                    const quantSlider = document.getElementById('quantization');
                    const quantDisplay = document.getElementById('quantizationValue');
                    if (quantSlider) quantSlider.value = 30;
                    if (quantDisplay) quantDisplay.textContent = '30%';
                    button.textContent = 'Restore Coherence';
                    button.classList.add('active');
                    
                    this.playDecoherentSound();
                } else {
                    this.quantization = 1.0;
                    const quantSlider = document.getElementById('quantization');
                    const quantDisplay = document.getElementById('quantizationValue');
                    if (quantSlider) quantSlider.value = 100;
                    if (quantDisplay) quantDisplay.textContent = '100%';
                    button.textContent = 'Decoherence';
                    button.classList.remove('active');
                }
            }

            async playDecoherentSound() {
                if (!this.audioContext) await this.initAudioContext();
                
                const { osc, gain } = this.createOscillator(440, 'sawtooth');
                
                const noise = this.audioContext.createBufferSource();
                const buffer = this.audioContext.createBuffer(1, this.audioContext.sampleRate * 2, this.audioContext.sampleRate);
                const data = buffer.getChannelData(0);
                
                for (let i = 0; i < data.length; i++) {
                    data[i] = (Math.random() - 0.5) * 0.1;
                }
                
                noise.buffer = buffer;
                const noiseGain = this.audioContext.createGain();
                noiseGain.gain.setValueAtTime(0.2, this.audioContext.currentTime);
                noiseGain.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 2);
                
                noise.connect(noiseGain);
                noiseGain.connect(this.audioContext.destination);
                
                gain.gain.setValueAtTime(0.1, this.audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 2);
                
                osc.start(this.audioContext.currentTime);
                noise.start(this.audioContext.currentTime);
                osc.stop(this.audioContext.currentTime + 2.2);
                noise.stop(this.audioContext.currentTime + 2.2);
            }

            // ADVANCED CONTROLS
            toggleStepControl() {
                this.stepControlEnabled = !this.stepControlEnabled;
                const button = document.getElementById('enableStepControl');
                const stepControls = document.getElementById('stepControls');
                
                if (this.stepControlEnabled) {
                    button.classList.add('active');
                    button.textContent = 'Disable Step Control';
                    if (stepControls) {
                        stepControls.style.display = 'block';
                        this.generateStepControls();
                    }
                } else {
                    button.classList.remove('active');
                    button.textContent = 'Enable Step Control';
                    if (stepControls) {
                        stepControls.style.display = 'none';
                    }
                }
                console.log('Step control enabled:', this.stepControlEnabled);
            }

            generateStepControls() {
                const container = document.getElementById('sequenceSteps');
                if (!container) {
                    console.warn('sequenceSteps container not found');
                    return;
                }
                
                container.innerHTML = '';
                
                for (let i = 0; i < this.sequenceLength; i++) {
                    const stepDiv = document.createElement('div');
                    stepDiv.style.cssText = `
                        padding: 0.5rem;
                        background: rgba(0,0,0,0.3);
                        border-radius: 6px;
                        text-align: center;
                        border: 1px solid rgba(255,255,255,0.1);
                    `;
                    
                    stepDiv.innerHTML = `
                        <div style="font-size: 0.7rem; margin-bottom: 0.25rem;">Step ${i+1}</div>
                        <select id="step-${i}" style="width: 100%; font-size: 0.7rem; background: rgba(0,0,0,0.5); color: white; border: 1px solid #333;">
                            <option value="-1">Rest</option>
                            ${this.energyLevels.map((e, idx) => `<option value="${idx}">E${idx+1}</option>`).join('')}
                        </select>
                        <div style="margin-top: 0.25rem;">
                            <input type="checkbox" id="excite-${i}" style="margin-right: 0.25rem;">
                            <label style="font-size: 0.6rem;">Excite</label>
                        </div>
                    `;
                    
                    container.appendChild(stepDiv);
                }
                
                setTimeout(() => {
                    for (let i = 0; i < this.sequenceLength; i++) {
                        const select = document.getElementById(`step-${i}`);
                        const checkbox = document.getElementById(`excite-${i}`);
                        
                        if (select) {
                            select.addEventListener('change', () => {
                                this.updateStepSequence();
                            });
                        }
                        if (checkbox) {
                            checkbox.addEventListener('change', () => {
                                this.updateStepSequence();
                            });
                        }
                    }
                }, 100);
                
                this.stepExcitations = [];
                for (let i = 0; i < this.sequenceLength; i++) {
                    this.stepExcitations.push({level: -1, excite: false});
                }
                console.log('Generated step controls for', this.sequenceLength, 'steps');
            }

            updateStepSequence() {
                if (!this.stepExcitations || this.stepExcitations.length !== this.sequenceLength) {
                    this.stepExcitations = [];
                    for (let i = 0; i < this.sequenceLength; i++) {
                        this.stepExcitations.push({level: -1, excite: false});
                    }
                }
                
                for (let i = 0; i < this.sequenceLength; i++) {
                    const select = document.getElementById(`step-${i}`);
                    const checkbox = document.getElementById(`excite-${i}`);
                    
                    if (select && checkbox) {
                        this.stepExcitations[i] = {
                            level: parseInt(select.value),
                            excite: checkbox.checked
                        };
                    }
                }
                
                console.log('Updated step sequence:', this.stepExcitations);
                this.generateSequenceFromSteps();
            }

            generateSequenceFromSteps() {
                this.currentSequence = [];
                
                this.stepExcitations.forEach((step, i) => {
                    if (step.level >= 0 && step.level < this.energyLevels.length) {
                        const energy = this.energyLevels[step.level];
                        const frequency = this.energyToFrequency(energy);
                        
                        const coherenceFactor = Math.exp(-i * this.evolutionSpeed / this.coherenceTime);
                        
                        this.currentSequence.push({
                            energyLevel: step.level,
                            frequency: frequency,
                            duration: this.evolutionSpeed,
                            amplitude: (step.excite ? 0.4 : 0.2) * coherenceFactor,
                            customExcitation: step.excite,
                            coherence: coherenceFactor
                        });
                    } else {
                        this.currentSequence.push({
                            energyLevel: -1,
                            frequency: 0,
                            duration: this.evolutionSpeed,
                            amplitude: 0
                        });
                    }
                });
                
                this.displaySequence();
                this.drawVisualization();
            }

            toggleMultiParticleMode() {
                this.multiParticleMode = !this.multiParticleMode;
                const button = document.getElementById('multiParticleMode');
                
                if (this.multiParticleMode) {
                    button.classList.add('active');
                    button.textContent = 'Single Particle';
                    this.updatePhysics();
                } else {
                    button.classList.remove('active');
                    button.textContent = 'Two-Particle Mode';
                    this.updatePhysics();
                }
                console.log('Multi-particle mode:', this.multiParticleMode);
            }

            toggleSynthModulation() {
                this.synthModulationEnabled = !this.synthModulationEnabled;
                const button = document.getElementById('synthModulationMode');
                
                if (this.synthModulationEnabled) {
                    button.classList.add('active');
                    button.textContent = 'Disable Synth Mod';
                    console.log('Synthesizer modulation enabled for sequencer');
                } else {
                    button.classList.remove('active');
                    button.textContent = 'Synth Modulation';
                    console.log('Synthesizer modulation disabled');
                }
            }

            testAdvancedParameters() {
                console.log('Testing advanced parameters...');
                console.log('Current temperature:', this.temperature, 'K');
                console.log('Current coupling strength:', this.couplingStrength);
                
                this.playParameterDemonstration();
            }

            async playParameterDemonstration() {
                if (!this.audioContext) await this.initAudioContext();
                
                const baseFreq = this.energyToFrequency(this.energyLevels[1]);
                
                const { osc: osc1, gain: gain1 } = this.createOscillator(baseFreq);
                gain1.gain.setValueAtTime(0.2, this.audioContext.currentTime);
                gain1.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 1);
                osc1.start(this.audioContext.currentTime);
                osc1.stop(this.audioContext.currentTime + 1.1);
                
                setTimeout(() => {
                    const { osc: osc2, gain: gain2 } = this.createOscillator(baseFreq);
                    
                    const fluctuationRate = this.temperature / 100;
                    const fluctuationDepth = this.temperature / 10;
                    
                    for (let t = 0; t < 1; t += 0.05) {
                        const detune = Math.sin(fluctuationRate * t * 2 * Math.PI) * fluctuationDepth;
                        osc2.detune.setValueAtTime(detune, this.audioContext.currentTime + t);
                    }
                    
                    gain2.gain.setValueAtTime(0.2, this.audioContext.currentTime);
                    gain2.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 1);
                    osc2.start(this.audioContext.currentTime);
                    osc2.stop(this.audioContext.currentTime + 1.1);
                    
                    console.log(`Parameter test: fluctuation rate = ${fluctuationRate.toFixed(2)} Hz, depth = ${fluctuationDepth.toFixed(1)} cents`);
                }, 1200);
            }

            // SEQUENCER METHODS
            generateQuantumSequence() {
                if (this.stepControlEnabled && this.stepExcitations.length > 0) {
                    this.generateSequenceFromSteps();
                    return;
                }
                
                this.currentSequence = [];
                
                console.log(`Generating ${this.sequenceType} with T=${this.temperature}K, coupling=${this.couplingStrength}, coherence=${this.coherenceTime}ms`);
                
                switch (this.sequenceType) {
                    case 'quantum-walk':
                        this.currentSequence = this.generateQuantumWalk();
                        break;
                    case 'spin-chain':
                        this.currentSequence = this.generateSpinChain();
                        break;
                    case 'tunneling':
                        this.currentSequence = this.generateTunnelingRhythm();
                        break;
                    case 'interference':
                        this.currentSequence = this.generateInterferenceBeat();
                        break;
                }
                
                this.displaySequence();
                this.drawVisualization();
            }

            generateQuantumWalk() {
                const sequence = [];
                let position = Math.floor(this.energyLevels.length / 2);
                
                for (let i = 0; i < this.sequenceLength; i++) {
                    const thermalNoise = (Math.random() - 0.5) * this.temperature / 1000;
                    const couplingModulation = Math.sin(i * this.couplingStrength) * 0.1;
                    
                    const coherenceFactor = Math.exp(-i * this.evolutionSpeed / this.coherenceTime);
                    const decoherenceNoise = (1 - coherenceFactor) * (Math.random() - 0.5) * 0.2;
                    
                    const step = Math.random() < (this.walkProbability + thermalNoise + decoherenceNoise) ? 1 : -1;
                    position = Math.max(0, Math.min(this.energyLevels.length - 1, position + step));
                    
                    let amplitude = 0.3 * coherenceFactor;
                    if (this.multiParticleMode) {
                        const correlation = Math.cos(i * this.couplingStrength * 2) * 0.1 + 0.1;
                        amplitude *= (1 + correlation);
                    }
                    
                    sequence.push({
                        energyLevel: position,
                        frequency: this.energyToFrequency(this.energyLevels[position]),
                        duration: this.evolutionSpeed,
                        amplitude: amplitude + couplingModulation,
                        thermal: thermalNoise,
                        coupling: couplingModulation,
                        coherence: coherenceFactor
                    });
                }
                
                return sequence;
            }

            generateSpinChain() {
                const sequence = [];
                let spinState = Math.random() < 0.5;
                const thermalDist = this.calculateThermalDistribution();
                
                for (let i = 0; i < this.sequenceLength; i++) {
                    const coherenceFactor = Math.exp(-i * this.evolutionSpeed / this.coherenceTime);
                    
                    const thermalFlipProb = this.temperature / 1000 * 0.1;
                    const couplingFlipProb = this.couplingStrength * 0.1;
                    const decoherenceFlipProb = (1 - coherenceFactor) * 0.2;
                    
                    if (Math.random() < (0.3 + thermalFlipProb + couplingFlipProb + decoherenceFlipProb)) {
                        spinState = !spinState;
                    }
                    
                    let energyLevel;
                    if (spinState) {
                        energyLevel = this.selectFromThermalDistribution(thermalDist, 0.75);
                    } else {
                        energyLevel = this.selectFromThermalDistribution(thermalDist, 0.25);
                    }
                    
                    let amplitude = (spinState ? 0.4 : 0.2) * coherenceFactor;
                    if (this.multiParticleMode) {
                        amplitude *= (1 + Math.sin(i * this.couplingStrength) * 0.2);
                    }
                    
                    sequence.push({
                        energyLevel: energyLevel,
                        frequency: this.energyToFrequency(this.energyLevels[energyLevel]),
                        duration: this.evolutionSpeed * (spinState ? 0.7 : 1.3),
                        amplitude: amplitude,
                        spin: spinState,
                        temperature: this.temperature,
                        coherence: coherenceFactor
                    });
                }
                
                return sequence;
            }

            generateTunnelingRhythm() {
                const sequence = [];
                
                for (let i = 0; i < this.sequenceLength; i++) {
                    const baseProb = Math.exp(-this.barrierHeight * Math.random());
                    const thermalBoost = Math.exp(this.temperature / 1000);
                    const couplingEffect = 1 + this.couplingStrength * 0.1;
                    
                    const tunnelingProb = baseProb * thermalBoost * couplingEffect * 0.1;
                    const shouldTunnel = Math.random() < tunnelingProb;
                    
                    if (shouldTunnel) {
                        const energyLevel = Math.floor(Math.random() * this.energyLevels.length);
                        const amplitude = 0.2 + tunnelingProb * 0.3;
                        
                        sequence.push({
                            energyLevel: energyLevel,
                            frequency: this.energyToFrequency(this.energyLevels[energyLevel]),
                            duration: this.evolutionSpeed * (0.3 + Math.random() * 0.4),
                            amplitude: amplitude,
                            tunneled: true,
                            tunnelingProb: tunnelingProb,
                            thermal: thermalBoost > 1.5 ? (thermalBoost - 1) * 0.1 : 0
                        });
                    } else {
                        sequence.push({
                            energyLevel: -1,
                            frequency: 0,
                            duration: this.evolutionSpeed,
                            amplitude: 0,
                            tunneled: false
                        });
                    }
                }
                
                console.log(`Tunneling rhythm: barrier=${this.barrierHeight}, temp boost=${Math.exp(this.temperature/1000).toFixed(2)}, events=${sequence.filter(s => s.tunneled).length}/${sequence.length}`);
                return sequence;
            }

            generateInterferenceBeat() {
                const sequence = [];
                
                for (let i = 0; i < this.sequenceLength; i++) {
                    const phase = (i / this.sequenceLength) * 2 * Math.PI;
                    
                    const wave1 = Math.sin(phase);
                    const wave2 = Math.cos(phase * (1 + this.couplingStrength * 0.1));
                    const thermalNoise = (Math.random() - 0.5) * this.temperature / 1000;
                    
                    const interference = (wave1 + wave2) / 2 + thermalNoise;
                    
                    const energyLevel = Math.floor((Math.abs(interference) + 1) * 0.5 * (this.energyLevels.length - 1));
                    
                    sequence.push({
                        energyLevel: energyLevel,
                        frequency: this.energyToFrequency(this.energyLevels[energyLevel]),
                        duration: this.evolutionSpeed,
                        amplitude: (Math.abs(interference) * 0.3) + 0.1,
                        interference: interference,
                        thermal: thermalNoise,
                        coupling: this.couplingStrength
                    });
                }
                
                return sequence;
            }

            calculateThermalDistribution() {
                const kT = this.temperature * 8.617e-5;
                const distribution = [];
                
                this.energyLevels.forEach(energy => {
                    const population = Math.exp(-energy / kT);
                    distribution.push(population);
                });
                
                const total = distribution.reduce((sum, pop) => sum + pop, 0);
                return distribution.map(pop => pop / total);
            }

            selectFromThermalDistribution(distribution, bias) {
                const biasedDist = distribution.map((prob, i) => {
                    const position = i / (distribution.length - 1);
                    return prob * (1 + (position - bias) * 0.5);
                });
                
                const total = biasedDist.reduce((sum, prob) => sum + prob, 0);
                const normalizedDist = biasedDist.map(prob => prob / total);
                
                const random = Math.random();
                let cumulative = 0;
                
                for (let i = 0; i < normalizedDist.length; i++) {
                    cumulative += normalizedDist[i];
                    if (random < cumulative) {
                        return i;
                    }
                }
                
                return distribution.length - 1;
            }

            displaySequence() {
                const display = document.getElementById('sequenceDisplay');
                if (!display) return;
                
                let displayText = `${this.sequenceType.toUpperCase()} (${this.currentSequence.length} steps)\n`;
                displayText += `T=${this.temperature}K, coupling=${this.couplingStrength}, coherence=${this.coherenceTime}ms\n`;
                
                if (this.synthModulationEnabled) {
                    displayText += `🎵 Synth Modulation: ${this.currentQuantumMode}\n`;
                }
                
                this.currentSequence.forEach((step, i) => {
                    if (step.energyLevel >= 0) {
                        let stepInfo = `${i+1}: E${step.energyLevel + 1}(${step.frequency.toFixed(1)}Hz)`;
                        
                        if (step.thermal && Math.abs(step.thermal) > 0.01) {
                            stepInfo += ` 🌡️${step.thermal > 0 ? '+' : ''}${(step.thermal*1000).toFixed(0)}`;
                        }
                        if (step.coupling && Math.abs(step.coupling) > 0.01) {
                            stepInfo += ` 🔗${step.coupling > 0 ? '+' : ''}${(step.coupling*100).toFixed(0)}%`;
                        }
                        if (step.coherence && step.coherence < 0.9) {
                            stepInfo += ` 💫${(step.coherence*100).toFixed(0)}%`;
                        }
                        if (step.customExcitation) {
                            stepInfo += ` ⚡`;
                        }
                        
                        displayText += stepInfo + ' ';
                    } else {
                        displayText += `${i+1}: REST `;
                    }
                    
                    if ((i + 1) % 4 === 0) displayText += '\n';
                });
                
                display.textContent = displayText;
            }

            async playQuantumSequence() {
                if (this.isSequencePlaying || this.currentSequence.length === 0) return;
                
                this.isSequencePlaying = true;
                const playButton = document.getElementById('playSequence');
                if (playButton) playButton.textContent = 'Playing...';
                
                console.log(`Playing sequence: ${this.currentSequence.length} steps, synth modulation: ${this.synthModulationEnabled}`);
                
                const playStep = async (stepIndex) => {
                    if (!this.isSequencePlaying || stepIndex >= this.currentSequence.length) {
                        if (this.sequenceLoop && this.isSequencePlaying) {
                            setTimeout(() => playStep(0), 100);
                        } else {
                            this.stopQuantumSequence();
                        }
                        return;
                    }
                    
                    const step = this.currentSequence[stepIndex];
                    
                    if (step.energyLevel >= 0 && step.amplitude > 0) {
                        this.playSequenceStep(step);
                    }
                    
                    setTimeout(() => playStep(stepIndex + 1), step.duration);
                };
                
                playStep(0);
            }

            playSequenceStep(step) {
                let finalAmplitude = step.amplitude;
                
                if (this.synthModulationEnabled) {
                    switch (this.currentQuantumMode) {
                        case 'superposition':
                            const harmonicFreq = step.frequency * 1.5;
                            const { osc: harmOsc, gain: harmGain } = this.createOscillator(harmonicFreq);
                            harmGain.gain.setValueAtTime(finalAmplitude * 0.3, this.audioContext.currentTime);
                            harmGain.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + step.duration / 1000 * 0.8);
                            harmOsc.start(this.audioContext.currentTime);
                            harmOsc.stop(this.audioContext.currentTime + step.duration / 1000);
                            break;
                            
                        case 'tunneling':
                            if (Math.random() < 0.3) {
                                finalAmplitude *= 0.1;
                            }
                            break;
                            
                        case 'interference':
                            const beatOsc = this.audioContext.createOscillator();
                            const beatGain = this.audioContext.createGain();
                            beatOsc.frequency.setValueAtTime(5, this.audioContext.currentTime);
                            beatGain.gain.setValueAtTime(finalAmplitude * 0.2, this.audioContext.currentTime);
                            beatOsc.connect(beatGain);
                            beatGain.connect(this.audioContext.destination);
                            beatOsc.start(this.audioContext.currentTime);
                            beatOsc.stop(this.audioContext.currentTime + step.duration / 1000);
                            break;
                    }
                }
                
                const { osc, gain } = this.createOscillator(step.frequency);
                
                gain.gain.setValueAtTime(finalAmplitude, this.audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + step.duration / 1000 * 0.8);
                
                osc.start(this.audioContext.currentTime);
                osc.stop(this.audioContext.currentTime + step.duration / 1000);
                
                if (step.energyLevel >= 0) {
                    this.animateParticle(step.energyLevel);
                }
            }

            stopQuantumSequence() {
                this.isSequencePlaying = false;
                const playButton = document.getElementById('playSequence');
                if (playButton) playButton.textContent = 'Play';
                
                if (this.sequenceInterval) {
                    clearInterval(this.sequenceInterval);
                    this.sequenceInterval = null;
                }
            }

            toggleSequenceLoop() {
                this.sequenceLoop = !this.sequenceLoop;
                const button = document.getElementById('loopSequence');
                if (button) {
                    button.textContent = `Loop: ${this.sequenceLoop ? 'On' : 'Off'}`;
                    button.classList.toggle('active', this.sequenceLoop);
                }
            }

            // ANALYSIS TOOLS
            analyzeSystem() {
                const analysis = {
                    energySpacing: [],
                    quantumNumber: this.energyLevels.length,
                    systemType: ['Square Well', 'Harmonic Oscillator', 'Double Well', 'Step Potential'][this.potentialShape],
                    degeneracy: this.calculateDegeneracy(),
                    tunnelingProb: this.calculateTunnelingProbability()
                };
                
                for (let i = 1; i < this.energyLevels.length; i++) {
                    analysis.energySpacing.push(this.energyLevels[i] - this.energyLevels[i-1]);
                }
                
                alert(`System Analysis:
Type: ${analysis.systemType}
Quantum States: ${analysis.quantumNumber}
Energy Spacing Pattern: ${analysis.energySpacing.slice(0,3).map(s => s.toFixed(2)).join(', ')}...
Average Spacing: ${(analysis.energySpacing.reduce((a,b) => a+b, 0) / analysis.energySpacing.length).toFixed(2)}
Tunneling Probability: ${analysis.tunnelingProb.toFixed(2)}%`);
            }

            compareStates() {
                if (this.energyLevels.length >= 2) {
                    this.playLevel(0);
                    setTimeout(() => this.playLevel(this.energyLevels.length - 1), 500);
                }
            }

            // PRESET MANAGEMENT
            loadPreset(presetName) {
                this.currentPreset = presetName;
                
                switch (presetName) {
                    case 'particle-box':
                        this.potentialShape = 0;
                        this.wellWidth = 100;
                        this.barrierHeight = 5;
                        break;
                    case 'harmonic':
                        this.potentialShape = 1;
                        this.wellWidth = 120;
                        this.barrierHeight = 3;
                        break;
                    case 'double-well':
                        this.potentialShape = 2;
                        this.wellWidth = 150;
                        this.barrierHeight = 7;
                        break;
                    case 'step':
                        this.potentialShape = 3;
                        this.wellWidth = 80;
                        this.barrierHeight = 8;
                        break;
                }
                
                // Update UI
                this.updateUIFromParameters();
                
                // Update preset button visual feedback
                document.querySelectorAll('.preset-btn[data-preset]').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.preset === presetName);
                });
                
                this.updatePhysics();
            }

            updateUIFromParameters() {
                const updates = [
                    ['wellWidth', this.wellWidth],
                    ['potentialShape', this.potentialShape],
                    ['barrierHeight', this.barrierHeight.toFixed(1)]
                ];
                
                updates.forEach(([id, value]) => {
                    const slider = document.getElementById(id);
                    const display = document.getElementById(id + 'Value');
                    if (slider) slider.value = value;
                    if (display) display.textContent = value;
                });
            }

            // PROFILE MANAGEMENT
            saveProfile() {
                const profile = {
                    name: `Quantum Profile ${new Date().toLocaleString()}`,
                    timestamp: Date.now(),
                    parameters: {
                        wellWidth: this.wellWidth,
                        quantization: this.quantization,
                        decayRate: this.decayRate,
                        synthMode: this.synthMode,
                        potentialShape: this.potentialShape,
                        barrierHeight: this.barrierHeight,
                        currentPreset: this.currentPreset,
                        currentQuantumMode: this.currentQuantumMode,
                        baseFrequency: this.baseFrequency,
                        frequencyMode: this.frequencyMode,
                        measurementStrength: this.measurementStrength,
                        temperature: this.temperature,
                        couplingStrength: this.couplingStrength,
                        stepControlEnabled: this.stepControlEnabled,
                        multiParticleMode: this.multiParticleMode,
                        decoherenceTime: this.decoherenceTime,
                        relaxationTime: this.relaxationTime,
                        sequenceLength: this.sequenceLength,
                        walkProbability: this.walkProbability,
                        evolutionSpeed: this.evolutionSpeed,
                        coherenceTime: this.coherenceTime,
                        sequenceType: this.sequenceType,
                        synthModulationEnabled: this.synthModulationEnabled
                    },
                    energyLevels: [...this.energyLevels],
                    stepExcitations: [...this.stepExcitations],
                    metadata: {
                        version: '0.2.0',
                        type: 'quantum-sonification-profile'
                    }
                };
                
                const blob = new Blob([JSON.stringify(profile, null, 2)], {
                    type: 'application/json'
                });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `quantum-profile-${Date.now()}.json`;
                a.click();
                URL.revokeObjectURL(url);
                
                alert('Profile saved to downloads!');
            }

            async loadProfileFromFile(file) {
                if (!file) return;
                
                try {
                    const text = await file.text();
                    const profile = JSON.parse(text);
                    
                    if (profile.metadata?.type === 'quantum-sonification-profile') {
                        this.loadProfileData(profile);
                        alert(`Loaded profile: ${profile.name}`);
                    } else {
                        alert('Invalid profile file format');
                    }
                } catch (error) {
                    alert('Error loading profile: ' + error.message);
                }
            }

            loadProfileData(profile) {
                const params = profile.parameters;
                
                // Restore all parameters
                Object.keys(params).forEach(key => {
                    if (this.hasOwnProperty(key)) {
                        this[key] = params[key];
                    }
                });
                
                // Restore step excitations if available
                if (profile.stepExcitations) {
                    this.stepExcitations = [...profile.stepExcitations];
                }
                
                // Update UI
                this.updateAllSliders();
                this.setQuantumMode(this.currentQuantumMode);
                this.setFrequencyMode(this.frequencyMode);
                this.setSequenceType(this.sequenceType);
                
                this.updatePhysics();
            }

            updateAllSliders() {
                const sliders = [
                    ['wellWidth', this.wellWidth],
                    ['quantization', this.quantization * 100],
                    ['decayRate', this.decayRate],
                    ['synthMode', this.synthMode],
                    ['potentialShape', this.potentialShape],
                    ['barrierHeight', this.barrierHeight],
                    ['baseFrequency', this.baseFrequency],
                    ['measurementStrength', this.measurementStrength * 100],
                    ['temperature', this.temperature],
                    ['couplingStrength', this.couplingStrength],
                    ['sequenceLength', this.sequenceLength],
                    ['walkProbability', this.walkProbability * 100],
                    ['evolutionSpeed', this.evolutionSpeed],
                    ['coherenceTime', this.coherenceTime]
                ];
                
                sliders.forEach(([id, value]) => {
                    const slider = document.getElementById(id);
                    const display = document.getElementById(id + 'Value');
                    if (slider) {
                        slider.value = value;
                        if (display) {
                            if (id === 'quantization' || id === 'walkProbability' || id === 'measurementStrength') {
                                display.textContent = value + '%';
                            } else if (id === 'decayRate' || id === 'evolutionSpeed' || id === 'coherenceTime') {
                                display.textContent = value + 'ms';
                            } else if (id === 'synthMode') {
                                const modes = ['Sine', 'Square', 'Sawtooth', 'Triangle'];
                                display.textContent = modes[value];
                            } else if (id === 'potentialShape') {
                                const shapes = ['Square Well', 'Harmonic', 'Double Well', 'Step', 'Custom'];
                                display.textContent = shapes[value];
                            } else if (id === 'temperature') {
                                display.textContent = value + 'K';
                            } else {
                                display.textContent = value;
                            }
                        }
                    }
                });
            }

            // RECORDING FUNCTIONS
            toggleRecording() {
                if (!this.isRecording) {
                    this.startRecording();
                } else {
                    this.stopRecording();
                }
            }

            async startRecording() {
                if (!this.audioContext) {
                    await this.initAudioContext();
                }
                
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ 
                        audio: {
                            echoCancellation: false,
                            noiseSuppression: false,
                            autoGainControl: false
                        } 
                    });
                    this.mediaRecorder = new MediaRecorder(stream, {
                        mimeType: 'audio/webm;codecs=opus'
                    });
                    this.recordedChunks = [];
                    
                    this.mediaRecorder.ondataavailable = (event) => {
                        if (event.data.size > 0) {
                            this.recordedChunks.push(event.data);
                        }
                    };
                    
                    this.mediaRecorder.onstop = () => {
                        const blob = new Blob(this.recordedChunks, { type: 'audio/webm' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `quantum-sonification-${Date.now()}.webm`;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);
                        
                        stream.getTracks().forEach(track => track.stop());
                    };
                    
                    this.mediaRecorder.start();
                    this.isRecording = true;
                    
                    const recordButton = document.getElementById('recordButton');
                    if (recordButton) recordButton.textContent = 'Stop Recording';
                    const indicator = document.getElementById('recordingIndicator');
                    if (indicator) indicator.classList.add('active');
                } catch (error) {
                    console.error('Recording failed:', error);
                    
                    let errorMsg = 'Recording failed. ';
                    if (error.name === 'NotAllowedError') {
                        errorMsg += 'Microphone permission denied. Please allow microphone access to enable recording.';
                    } else if (error.name === 'NotFoundError') {
                        errorMsg += 'No microphone found.';
                    } else {
                        errorMsg += 'Please check microphone permissions and try again.';
                    }
                    
                    alert(errorMsg);
                }
            }

            stopRecording() {
                if (this.mediaRecorder && this.isRecording) {
                    this.mediaRecorder.stop();
                    this.isRecording = false;
                    
                    const recordButton = document.getElementById('recordButton');
                    if (recordButton) recordButton.textContent = 'Record';
                    const indicator = document.getElementById('recordingIndicator');
                    if (indicator) indicator.classList.remove('active');
                }
            }
        }

        // Initialize the app when page loads
        document.addEventListener('DOMContentLoaded', () => {
            try {
                window.quantumApp = new QuantumSonificationApp();
                console.log('✅ Eigensound Lite successfully initialized!');
            } catch (error) {
                console.error('❌ Failed to initialize app:', error);
                alert('Failed to load Eigensound Lite. Please refresh the page.');
            }
        });

        // Handle window resize
        window.addEventListener('resize', () => {
            setTimeout(() => {
                const app = window.quantumApp;
                if (app) {
                    app.setupCanvas();
                    app.drawVisualization();
                }
            }, 100);
        });
    </script>
</body>
</html>