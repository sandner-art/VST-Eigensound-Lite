<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Touch Synthesizer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            color: #fff;
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            touch-action: none;
            height: 100vh;
            width: 100vw;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
        }

        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            background: radial-gradient(circle at center, #001122 0%, #000 100%);
            cursor: none;
            will-change: contents;
        }

        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            display: flex;
            gap: 15px;
            opacity: 0.9;
            transition: opacity 0.3s ease;
        }

        #controls.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .control-btn {
            background: rgba(255, 255, 255, 0.05);
            border: none;
            color: #fff;
            padding: 12px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 16px;
            width: 44px;
            height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(20px);
            transition: all 0.3s ease;
            user-select: none;
        }

        .control-btn:hover, .control-btn.active {
            background: rgba(255, 255, 255, 0.15);
            transform: scale(1.1);
        }

        #menuControls {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 100;
            opacity: 0.9;
            transition: opacity 0.3s ease;
        }

        #menuControls.hidden {
            opacity: 0;
            pointer-events: none;
        }

        #optionsMenu {
            position: absolute;
            top: 70px;
            right: 20px;
            background: rgba(0, 0, 0, 0.95);
            backdrop-filter: blur(30px);
            border-radius: 20px;
            padding: 25px;
            min-width: 320px;
            max-height: 80vh;
            overflow-y: auto;
            z-index: 200;
            display: none;
            opacity: 0;
            transform: translateY(-10px);
            transition: all 0.3s ease;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        #optionsMenu.show {
            display: block;
            opacity: 1;
            transform: translateY(0);
        }

        .menu-section {
            margin-bottom: 25px;
        }

        .menu-section:last-child {
            margin-bottom: 0;
        }

        .menu-title {
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 15px;
            color: #4ecdc4;
            text-transform: uppercase;
            letter-spacing: 1px;
            border-bottom: 1px solid rgba(78, 205, 196, 0.3);
            padding-bottom: 5px;
        }

        .setting-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            font-size: 13px;
        }

        .setting-control {
            background: rgba(255, 255, 255, 0.1);
            border: none;
            color: #fff;
            padding: 8px 12px;
            border-radius: 15px;
            font-size: 12px;
            cursor: pointer;
            min-width: 60px;
            text-align: center;
            transition: background 0.3s ease;
        }

        .setting-control:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .setting-slider {
            width: 120px;
            height: 4px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
            outline: none;
            cursor: pointer;
            appearance: none;
        }

        .setting-slider::-webkit-slider-thumb {
            appearance: none;
            width: 16px;
            height: 16px;
            background: #4ecdc4;
            border-radius: 50%;
            cursor: pointer;
        }

        .setting-value {
            min-width: 40px;
            text-align: right;
            font-size: 12px;
            color: #4ecdc4;
        }

        #fileInput {
            display: none;
        }

        #info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            right: 20px;
            text-align: center;
            font-size: 11px;
            opacity: 0.6;
            z-index: 100;
            transition: opacity 0.3s ease;
        }

        #info.hidden {
            opacity: 0;
        }

        .beat-indicator {
            position: absolute;
            pointer-events: none;
            border: 2px solid #ff6b6b;
            border-radius: 50%;
            animation: beatPulse 0.3s ease-out;
            width: 40px;
            height: 40px;
        }

        @keyframes beatPulse {
            0% { transform: scale(0.5); opacity: 1; }
            100% { transform: scale(2); opacity: 0; }
        }

        .mode-indicator {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 25px 45px;
            border-radius: 25px;
            font-size: 28px;
            font-weight: bold;
            z-index: 1000;
            text-align: center;
            backdrop-filter: blur(20px);
            pointer-events: none;
            animation: modeChange 1.8s ease-out forwards;
            border: 2px solid rgba(255, 255, 255, 0.3);
        }

        @keyframes modeChange {
            0% { transform: translate(-50%, -50%) scale(0.3); opacity: 0; }
            25% { transform: translate(-50%, -50%) scale(1.1); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 0; }
        }

        .pad-mode-indicator {
            position: absolute;
            bottom: 60px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 12px 25px;
            border-radius: 25px;
            font-size: 12px;
            opacity: 0.8;
            z-index: 100;
            display: none;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .pad-mode-indicator.show {
            display: block;
        }

        .effect-visualization {
            position: absolute;
            pointer-events: none;
            border: 3px solid;
            border-radius: 50%;
            animation: effectRipple 1.2s ease-out;
        }

        @keyframes effectRipple {
            0% { transform: scale(0.3); opacity: 0.9; }
            100% { transform: scale(4); opacity: 0; }
        }

        .app-info {
            font-size: 12px;
            line-height: 1.6;
            color: #aaa;
        }

        .app-info h3 {
            color: #4ecdc4;
            margin-bottom: 10px;
            font-size: 16px;
        }

        .app-info p {
            margin-bottom: 8px;
        }

        .error-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #ff4444;
            color: white;
            padding: 20px 30px;
            border-radius: 15px;
            z-index: 2000;
            font-size: 14px;
            text-align: center;
            animation: errorFade 3s ease-out forwards;
        }

        @keyframes errorFade {
            0%, 80% { opacity: 1; }
            100% { opacity: 0; }
        }

        /* Custom scrollbar for menu */
        #optionsMenu::-webkit-scrollbar {
            width: 6px;
        }

        #optionsMenu::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
        }

        #optionsMenu::-webkit-scrollbar-thumb {
            background: #4ecdc4;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <div id="controls">
        <button class="control-btn" id="startBtn" title="Start/Pause">â–¶</button>
        <button class="control-btn" id="scaleBtn" title="Musical Scale">P</button>
        <button class="control-btn" id="modeBtn" title="Instrument Mode">ðŸŽ¹</button>
        <button class="control-btn" id="fullscreenBtn" title="Fullscreen">â›¶</button>
        <button class="control-btn" id="resetBtn" title="Reset">â†»</button>
    </div>

    <div id="menuControls">
        <button class="control-btn" id="menuBtn" title="Settings">â‹®</button>
    </div>

    <div id="optionsMenu">
        <div class="menu-section">
            <div class="menu-title">Audio Settings</div>
            <div class="setting-row">
                <span>Master Volume</span>
                <input type="range" class="setting-slider" id="volumeSlider" min="0" max="100" value="70">
                <span class="setting-value" id="volumeValue">70%</span>
            </div>
            <div class="setting-row">
                <span>Polyphony</span>
                <input type="range" class="setting-slider" id="polyphonySlider" min="2" max="12" value="6">
                <span class="setting-value" id="polyphonyValue">6</span>
            </div>
            <div class="setting-row">
                <span>Note Timeout (s)</span>
                <input type="range" class="setting-slider" id="timeoutSlider" min="1" max="10" value="3">
                <span class="setting-value" id="timeoutValue">3s</span>
            </div>
            <div class="setting-row">
                <span>Waveform</span>
                <button class="setting-control" id="waveformBtn">Sine</button>
            </div>
            <div class="setting-row">
                <span>Load Samples</span>
                <button class="setting-control" id="loadSamplesBtn">Browse</button>
            </div>
        </div>

        <div class="menu-section">
            <div class="menu-title">Visual Settings</div>
            <div class="setting-row">
                <span>Trail Length</span>
                <input type="range" class="setting-slider" id="trailSlider" min="5" max="50" value="20">
                <span class="setting-value" id="trailValue">20</span>
            </div>
            <div class="setting-row">
                <span>Frame Rate</span>
                <input type="range" class="setting-slider" id="fpsSlider" min="15" max="60" value="30">
                <span class="setting-value" id="fpsValue">30fps</span>
            </div>
        </div>

        <div class="menu-section">
            <div class="menu-title">Effects & Modulation</div>
            <div class="setting-row">
                <span>Reverb Amount</span>
                <input type="range" class="setting-slider" id="reverbSlider" min="0" max="100" value="30">
                <span class="setting-value" id="reverbValue">30%</span>
            </div>
            <div class="setting-row">
                <span>Filter Cutoff</span>
                <input type="range" class="setting-slider" id="filterSlider" min="0" max="100" value="50">
                <span class="setting-value" id="filterValue">50%</span>
            </div>
            <div class="setting-row">
                <span>Distortion</span>
                <input type="range" class="setting-slider" id="distortionSlider" min="0" max="100" value="0">
                <span class="setting-value" id="distortionValue">0%</span>
            </div>
            <div class="setting-row">
                <span>Modulation Strength</span>
                <input type="range" class="setting-slider" id="modulationSlider" min="0" max="100" value="50">
                <span class="setting-value" id="modulationValue">50%</span>
            </div>
            <div class="setting-row">
                <span>Touch Sensitivity</span>
                <input type="range" class="setting-slider" id="sensitivitySlider" min="0" max="100" value="70">
                <span class="setting-value" id="sensitivityValue">70%</span>
            </div>
        </div>

        <div class="menu-section">
            <div class="menu-title">About</div>
            <div class="app-info">
                <h3>Touch Synthesizer v2.0</h3>
                <p>Interactive musical instrument with motion control, multi-touch synthesis, and real-time effects processing.</p>
                <p><strong>Touch Controls:</strong></p>
                <p>â€¢ Touch & hold: Play sustained notes</p>
                <p>â€¢ Quick tap: Trigger percussion beats</p>
                <p>â€¢ Two-finger pad mode: Note + effect control</p>
                <p>â€¢ Multi-touch: Create harmonies</p>
                <p><strong>Motion Controls:</strong></p>
                <p>â€¢ Shake device: Cycle through instrument modes</p>
                <p>â€¢ Tilt device: Modulate sound parameters</p>
                <p><strong>Modes:</strong></p>
                <p>â€¢ SYNTH: Classic multi-touch synthesis</p>
                <p>â€¢ DRUMS: Rhythmic patterns and beats</p>
                <p>â€¢ FX: Sound effects and processing</p>
                <p>â€¢ AMBIENT: Atmospheric soundscapes</p>
                <p>â€¢ PAD: Two-finger collaborative playing</p>
            </div>
        </div>
    </div>

    <input type="file" id="fileInput" accept="audio/*" multiple>

    <div class="pad-mode-indicator" id="padModeIndicator">
        <div>PAD MODE: First finger plays notes â€¢ Second finger controls effects</div>
    </div>

    <div id="info">
        Touch to play â€¢ Tap for beats â€¢ Shake to change modes â€¢ Menu for settings
    </div>

    <script>
        class TouchSynth {
            constructor() {
                try {
                    this.initializeProperties();
                    this.setupCanvas();
                    this.setupAudioDefaults();
                    this.setupEventListeners();
                    this.setupSettingsHandlers();
                    this.setupDefaultBeats();
                    this.setupMotionDetection();
                    this.startAnimationLoop();
                    console.log('TouchSynth v2.0 initialized successfully');
                } catch (error) {
                    console.error('Error initializing TouchSynth:', error);
                    this.showError('Initialization failed');
                }
            }

            initializeProperties() {
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.isStarted = false;
                this.synths = new Map();
                this.touches = new Map();
                this.colors = ['#4ecdc4', '#ff6b6b', '#45b7d1', '#f9ca24', '#f0932b', '#eb4d4b', '#6c5ce7', '#fd79a8'];
                
                // Audio settings
                this.currentScale = 'pentatonic';
                this.currentWave = 'sine';
                this.masterVolume = 0.7;
                this.maxPolyphony = 6;
                this.activeSynths = 0;
                this.sampleMode = false;
                this.customSamples = [];
                this.stuckNoteTimeout = 3000;
                this.modulationStrength = 0.5;
                this.touchSensitivity = 0.7;
                
                // Visual settings
                this.maxTrailLength = 20;
                this.targetFPS = 30;
                this.animationId = null;
                this.lastFrameTime = 0;
                
                // Effects settings
                this.reverbAmount = 0.3;
                this.filterAmount = 0.5;
                this.distortionAmount = 0;
                
                // Audio nodes - initialize as null
                this.masterGain = null;
                this.compressor = null;
                this.globalReverb = null;
                this.globalFilter = null;
                this.globalDistortion = null;
                
                // Beat detection
                this.lastTapTime = 0;
                this.tapThreshold = 200;
                this.beatSounds = [];
                
                // Mode system
                this.instrumentMode = 'synth';
                this.motionModes = ['synth', 'percussion', 'effects', 'ambient', 'pad'];
                this.motionModeNames = ['SYNTH', 'DRUMS', 'FX', 'AMBIENT', 'PAD'];
                this.motionModeColors = ['#4ecdc4', '#ff6b6b', '#f9ca24', '#6c5ce7', '#fd79a8'];
                this.lastShakeTime = 0;
                this.shakeCooldown = 1000;
                this.shakeThreshold = 12;
                this.motionSupported = false;
                
                // Pad mode specific
                this.padMode = false;
                this.padTouches = { note: null, effect: null };
                this.effectRadius = 100;
                
                // UI state
                this.isFullscreen = false;
                this.menuOpen = false;
                
                // Timers and cleanup
                this.noteTimeouts = new Map();
                this.autoRhythmInterval = null;
                this.rhythmStep = 0;
                
                // Musical scales
                this.scales = {
                    pentatonic: [261.63, 293.66, 329.63, 392.00, 440.00, 523.25],
                    major: [261.63, 293.66, 329.63, 349.23, 392.00, 440.00, 493.88, 523.25],
                    minor: [261.63, 293.66, 311.13, 349.23, 392.00, 415.30, 466.16, 523.25],
                    chromatic: [261.63, 277.18, 293.66, 311.13, 329.63, 349.23, 369.99, 392.00]
                };
                
                this.waveTypes = ['sine', 'triangle', 'sawtooth', 'square'];
                this.scaleNames = ['P', 'M', 'm', 'C'];
                this.waveTypeNames = ['Sine', 'Triangle', 'Sawtooth', 'Square'];
                this.modeIcons = ['ðŸŽ¹', 'ðŸ¥', 'ðŸŽ›ï¸', 'ðŸŒŠ', 'ðŸŽšï¸'];
            }

            setupAudioDefaults() {
                // Initialize audio nodes as null to prevent errors
                this.masterGain = null;
                this.compressor = null;
                this.globalReverb = null;
                this.globalFilter = null;
                this.globalDistortion = null;
            }

            showError(message) {
                const errorDiv = document.createElement('div');
                errorDiv.className = 'error-message';
                errorDiv.textContent = `Error: ${message}`;
                document.body.appendChild(errorDiv);
                setTimeout(() => {
                    if (errorDiv.parentNode) {
                        errorDiv.remove();
                    }
                }, 3000);
            }

            setupCanvas() {
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());
            }

            resizeCanvas() {
                const dpr = Math.min(window.devicePixelRatio || 1, 2);
                this.canvas.width = window.innerWidth * dpr;
                this.canvas.height = window.innerHeight * dpr;
                this.canvas.style.width = window.innerWidth + 'px';
                this.canvas.style.height = window.innerHeight + 'px';
                this.ctx.scale(dpr, dpr);
            }

            async setupAudioChain() {
                try {
                    if (this.masterGain) return true; // Already initialized
                    
                    await Tone.start();
                    console.log('Tone.js started successfully');
                    
                    // Create master audio chain with error checking
                    this.masterGain = new Tone.Gain(this.masterVolume);
                    this.compressor = new Tone.Compressor(-12, 3);
                    
                    // Create global effects
                    this.globalReverb = new Tone.Reverb(1.5);
                    this.globalFilter = new Tone.Filter(1000, 'lowpass');
                    this.globalDistortion = new Tone.Distortion(0);
                    
                    // Wait for reverb to generate
                    await this.globalReverb.generate();
                    
                    // Connect effects chain: masterGain -> distortion -> filter -> reverb -> compressor -> destination
                    this.masterGain.connect(this.globalDistortion);
                    this.globalDistortion.connect(this.globalFilter);
                    this.globalFilter.connect(this.globalReverb);
                    this.globalReverb.connect(this.compressor);
                    this.compressor.toDestination();
                    
                    // Set initial effect values safely
                    this.updateEffects();
                    
                    console.log('Audio chain setup complete');
                    return true;
                } catch (error) {
                    console.error('Audio setup failed:', error);
                    this.showError('Audio initialization failed: ' + error.message);
                    return false;
                }
            }

            updateEffects() {
                try {
                    if (this.globalReverb && this.globalReverb.roomSize) {
                        this.globalReverb.roomSize.value = this.reverbAmount;
                    }
                    if (this.globalFilter && this.globalFilter.frequency) {
                        this.globalFilter.frequency.value = 200 + (this.filterAmount * 3000);
                    }
                    if (this.globalDistortion) {
                        this.globalDistortion.distortion = this.distortionAmount;
                    }
                } catch (error) {
                    console.error('Effect update failed:', error);
                }
            }

            setupSettingsHandlers() {
                try {
                    // Volume control
                    const volumeSlider = document.getElementById('volumeSlider');
                    const volumeValue = document.getElementById('volumeValue');
                    volumeSlider.addEventListener('input', (e) => {
                        this.masterVolume = parseInt(e.target.value) / 100;
                        volumeValue.textContent = e.target.value + '%';
                        if (this.masterGain) {
                            this.masterGain.gain.rampTo(this.masterVolume, 0.1);
                        }
                    });
                    
                    // Polyphony
                    const polyphonySlider = document.getElementById('polyphonySlider');
                    const polyphonyValue = document.getElementById('polyphonyValue');
                    polyphonySlider.addEventListener('input', (e) => {
                        this.maxPolyphony = parseInt(e.target.value);
                        polyphonyValue.textContent = this.maxPolyphony;
                    });
                    
                    // Timeout
                    const timeoutSlider = document.getElementById('timeoutSlider');
                    const timeoutValue = document.getElementById('timeoutValue');
                    timeoutSlider.addEventListener('input', (e) => {
                        this.stuckNoteTimeout = parseInt(e.target.value) * 1000;
                        timeoutValue.textContent = e.target.value + 's';
                    });
                    
                    // Waveform button
                    const waveformBtn = document.getElementById('waveformBtn');
                    waveformBtn.addEventListener('click', () => {
                        this.cycleWave();
                        waveformBtn.textContent = this.waveTypeNames[this.waveTypes.indexOf(this.currentWave)];
                    });
                    
                    // Trail length
                    const trailSlider = document.getElementById('trailSlider');
                    const trailValue = document.getElementById('trailValue');
                    trailSlider.addEventListener('input', (e) => {
                        this.maxTrailLength = parseInt(e.target.value);
                        trailValue.textContent = this.maxTrailLength;
                    });
                    
                    // Frame rate
                    const fpsSlider = document.getElementById('fpsSlider');
                    const fpsValue = document.getElementById('fpsValue');
                    fpsSlider.addEventListener('input', (e) => {
                        this.targetFPS = parseInt(e.target.value);
                        fpsValue.textContent = e.target.value + 'fps';
                    });
                    
                    // Reverb
                    const reverbSlider = document.getElementById('reverbSlider');
                    const reverbValue = document.getElementById('reverbValue');
                    reverbSlider.addEventListener('input', (e) => {
                        this.reverbAmount = parseInt(e.target.value) / 100;
                        reverbValue.textContent = e.target.value + '%';
                        this.updateEffects();
                    });
                    
                    // Filter
                    const filterSlider = document.getElementById('filterSlider');
                    const filterValue = document.getElementById('filterValue');
                    filterSlider.addEventListener('input', (e) => {
                        this.filterAmount = parseInt(e.target.value) / 100;
                        filterValue.textContent = e.target.value + '%';
                        this.updateEffects();
                    });
                    
                    // Distortion
                    const distortionSlider = document.getElementById('distortionSlider');
                    const distortionValue = document.getElementById('distortionValue');
                    distortionSlider.addEventListener('input', (e) => {
                        this.distortionAmount = parseInt(e.target.value) / 100;
                        distortionValue.textContent = e.target.value + '%';
                        this.updateEffects();
                    });
                    
                    // Modulation strength
                    const modulationSlider = document.getElementById('modulationSlider');
                    const modulationValue = document.getElementById('modulationValue');
                    modulationSlider.addEventListener('input', (e) => {
                        this.modulationStrength = parseInt(e.target.value) / 100;
                        modulationValue.textContent = e.target.value + '%';
                    });
                    
                    // Touch sensitivity
                    const sensitivitySlider = document.getElementById('sensitivitySlider');
                    const sensitivityValue = document.getElementById('sensitivityValue');
                    sensitivitySlider.addEventListener('input', (e) => {
                        this.touchSensitivity = parseInt(e.target.value) / 100;
                        sensitivityValue.textContent = e.target.value + '%';
                    });
                    
                    // Load samples
                    document.getElementById('loadSamplesBtn').addEventListener('click', () => {
                        document.getElementById('fileInput').click();
                    });
                    
                } catch (error) {
                    console.error('Settings handlers setup failed:', error);
                }
            }

            setupDefaultBeats() {
                try {
                    this.beatSounds = [
                        { type: 'kick', freq: 60, decay: 0.3 },
                        { type: 'snare', freq: 200, decay: 0.15 },
                        { type: 'hihat', freq: 8000, decay: 0.05 }
                    ];
                } catch (error) {
                    console.error('Beat setup failed:', error);
                }
            }

            setupMotionDetection() {
                try {
                    if (typeof DeviceMotionEvent !== 'undefined') {
                        if (typeof DeviceMotionEvent.requestPermission === 'function') {
                            // iOS 13+ permission request
                            DeviceMotionEvent.requestPermission()
                                .then(permissionState => {
                                    if (permissionState === 'granted') {
                                        this.enableMotionDetection();
                                    }
                                })
                                .catch(error => {
                                    console.error('Motion permission denied:', error);
                                });
                        } else {
                            // Non-iOS or older iOS
                            this.enableMotionDetection();
                        }
                    }
                } catch (error) {
                    console.error('Motion detection setup failed:', error);
                }
            }

            enableMotionDetection() {
                try {
                    let lastAcceleration = { x: 0, y: 0, z: 0 };
                    
                    window.addEventListener('devicemotion', (event) => {
                        if (!this.isStarted) return;
                        
                        const acc = event.accelerationIncludingGravity;
                        if (!acc) return;
                        
                        const currentAcceleration = {
                            x: acc.x || 0,
                            y: acc.y || 0,
                            z: acc.z || 0
                        };
                        
                        // Calculate shake intensity
                        const deltaX = Math.abs(currentAcceleration.x - lastAcceleration.x);
                        const deltaY = Math.abs(currentAcceleration.y - lastAcceleration.y);
                        const deltaZ = Math.abs(currentAcceleration.z - lastAcceleration.z);
                        
                        const shakeIntensity = deltaX + deltaY + deltaZ;
                        
                        // Detect shake gesture
                        const now = Date.now();
                        if (shakeIntensity > this.shakeThreshold && 
                            now - this.lastShakeTime > this.shakeCooldown) {
                            this.handleShake();
                            this.lastShakeTime = now;
                        }
                        
                        // Apply modulation based on device orientation
                        this.applyOrientationModulation(currentAcceleration);
                        
                        lastAcceleration = currentAcceleration;
                    });
                    
                    this.motionSupported = true;
                    console.log('Motion detection enabled');
                } catch (error) {
                    console.error('Motion detection failed:', error);
                }
            }

            applyOrientationModulation(acceleration) {
                try {
                    if (!this.globalFilter || !this.modulationStrength) return;
                    
                    const tiltModulation = (acceleration.x * this.modulationStrength) / 10;
                    const baseFreq = 200 + (this.filterAmount * 3000);
                    const modulatedFreq = Math.max(100, Math.min(4000, baseFreq + (tiltModulation * 500)));
                    
                    if (this.globalFilter.frequency) {
                        this.globalFilter.frequency.rampTo(modulatedFreq, 0.1);
                    }
                } catch (error) {
                    console.error('Orientation modulation failed:', error);
                }
            }

            setupEventListeners() {
                try {
                    // Touch events with error handling
                    this.canvas.addEventListener('touchstart', this.handleTouchStart.bind(this), { passive: false });
                    this.canvas.addEventListener('touchmove', this.handleTouchMove.bind(this), { passive: false });
                    this.canvas.addEventListener('touchend', this.handleTouchEnd.bind(this), { passive: false });
                    this.canvas.addEventListener('touchcancel', this.handleTouchEnd.bind(this), { passive: false });

                    // Mouse events for desktop testing
                    this.canvas.addEventListener('mousedown', this.handleMouseDown.bind(this));
                    this.canvas.addEventListener('mousemove', this.handleMouseMove.bind(this));
                    this.canvas.addEventListener('mouseup', this.handleMouseUp.bind(this));

                    // Control buttons
                    document.getElementById('startBtn').addEventListener('click', this.toggleStart.bind(this));
                    document.getElementById('scaleBtn').addEventListener('click', this.cycleScale.bind(this));
                    document.getElementById('modeBtn').addEventListener('click', this.cycleMode.bind(this));
                    document.getElementById('fullscreenBtn').addEventListener('click', this.toggleFullscreen.bind(this));
                    document.getElementById('resetBtn').addEventListener('click', this.reset.bind(this));
                    document.getElementById('menuBtn').addEventListener('click', this.toggleMenu.bind(this));
                    
                    // File input
                    document.getElementById('fileInput').addEventListener('change', this.loadSamples.bind(this));
                    
                    // Close menu when clicking outside
                    document.addEventListener('click', (e) => {
                        const menu = document.getElementById('optionsMenu');
                        const menuBtn = document.getElementById('menuBtn');
                        if (this.menuOpen && !menu.contains(e.target) && e.target !== menuBtn) {
                            this.toggleMenu();
                        }
                    });
                    
                    // Fullscreen change events
                    document.addEventListener('fullscreenchange', this.handleFullscreenChange.bind(this));
                    document.addEventListener('webkitfullscreenchange', this.handleFullscreenChange.bind(this));
                    
                    // Visibility change to prevent audio issues
                    document.addEventListener('visibilitychange', () => {
                        if (document.hidden) {
                            this.stopAllNotes();
                        }
                    });
                    
                    console.log('Event listeners setup complete');
                } catch (error) {
                    console.error('Event listeners setup failed:', error);
                }
            }

            async toggleStart() {
                try {
                    if (!this.isStarted) {
                        const audioReady = await this.setupAudioChain();
                        if (!audioReady) return;
                        
                        this.isStarted = true;
                        document.getElementById('startBtn').textContent = 'â¸';
                        document.getElementById('startBtn').classList.add('active');
                        console.log('Audio started successfully');
                    } else {
                        this.stopAllNotes();
                        this.isStarted = false;
                        document.getElementById('startBtn').textContent = 'â–¶';
                        document.getElementById('startBtn').classList.remove('active');
                        console.log('Audio stopped');
                    }
                } catch (error) {
                    console.error('Toggle start failed:', error);
                    this.showError('Audio start failed: ' + error.message);
                }
            }

            cycleScale() {
                try {
                    const scales = Object.keys(this.scales);
                    const currentIndex = scales.indexOf(this.currentScale);
                    const nextIndex = (currentIndex + 1) % scales.length;
                    this.currentScale = scales[nextIndex];
                    document.getElementById('scaleBtn').textContent = this.scaleNames[nextIndex];
                } catch (error) {
                    console.error('Scale cycling failed:', error);
                }
            }

            cycleWave() {
                try {
                    const currentIndex = this.waveTypes.indexOf(this.currentWave);
                    const nextIndex = (currentIndex + 1) % this.waveTypes.length;
                    this.currentWave = this.waveTypes[nextIndex];
                } catch (error) {
                    console.error('Wave cycling failed:', error);
                }
            }

            cycleMode() {
                try {
                    const currentIndex = this.motionModes.indexOf(this.instrumentMode);
                    const nextIndex = (currentIndex + 1) % this.motionModes.length;
                    this.instrumentMode = this.motionModes[nextIndex];
                    document.getElementById('modeBtn').textContent = this.modeIcons[nextIndex];
                    
                    // Update pad mode
                    this.padMode = (this.instrumentMode === 'pad');
                    document.getElementById('padModeIndicator').classList.toggle('show', this.padMode);
                    
                    this.showModeChange();
                    this.applyModeEffects();
                } catch (error) {
                    console.error('Mode cycling failed:', error);
                }
            }

            toggleFullscreen() {
                try {
                    if (!this.isFullscreen) {
                        const elem = document.documentElement;
                        if (elem.requestFullscreen) {
                            elem.requestFullscreen();
                        } else if (elem.webkitRequestFullscreen) {
                            elem.webkitRequestFullscreen();
                        }
                    } else {
                        if (document.exitFullscreen) {
                            document.exitFullscreen();
                        } else if (document.webkitExitFullscreen) {
                            document.webkitExitFullscreen();
                        }
                    }
                } catch (error) {
                    console.error('Fullscreen toggle failed:', error);
                }
            }

            handleFullscreenChange() {
                try {
                    this.isFullscreen = !!(document.fullscreenElement || document.webkitFullscreenElement);
                    
                    const controls = document.getElementById('controls');
                    const menuControls = document.getElementById('menuControls');
                    const info = document.getElementById('info');
                    
                    if (this.isFullscreen) {
                        controls.classList.add('hidden');
                        info.classList.add('hidden');
                        menuControls.classList.remove('hidden');
                    } else {
                        controls.classList.remove('hidden');
                        info.classList.remove('hidden');
                        menuControls.classList.add('hidden');
                        if (this.menuOpen) {
                            this.toggleMenu();
                        }
                    }
                } catch (error) {
                    console.error('Fullscreen change handling failed:', error);
                }
            }

            toggleMenu() {
                try {
                    this.menuOpen = !this.menuOpen;
                    const menu = document.getElementById('optionsMenu');
                    menu.classList.toggle('show', this.menuOpen);
                } catch (error) {
                    console.error('Menu toggle failed:', error);
                }
            }

            async loadSamples(event) {
                try {
                    const files = Array.from(event.target.files);
                    if (files.length === 0) return;
                    
                    let loadedCount = 0;
                    for (const file of files.slice(0, 8)) { // Limit to 8 samples
                        const buffer = await this.fileToBuffer(file);
                        if (buffer) {
                            this.customSamples.push({
                                name: file.name,
                                buffer: buffer
                            });
                            loadedCount++;
                        }
                    }
                    
                    if (loadedCount > 0) {
                        this.sampleMode = true;
                        this.showError(`Loaded ${loadedCount} samples successfully`);
                    }
                } catch (error) {
                    console.error('Sample loading failed:', error);
                    this.showError('Sample loading failed: ' + error.message);
                }
            }

            fileToBuffer(file) {
                return new Promise((resolve) => {
                    const reader = new FileReader();
                    reader.onload = async (e) => {
                        try {
                            const arrayBuffer = e.target.result;
                            const audioBuffer = await Tone.Buffer.fromArray(arrayBuffer);
                            resolve(audioBuffer);
                        } catch (error) {
                            console.error('Buffer creation failed for', file.name, ':', error);
                            resolve(null);
                        }
                    };
                    reader.onerror = () => {
                        console.error('File reading failed for', file.name);
                        resolve(null);
                    };
                    reader.readAsArrayBuffer(file);
                });
            }

            handleShake() {
                try {
                    const currentIndex = this.motionModes.indexOf(this.instrumentMode);
                    const nextIndex = (currentIndex + 1) % this.motionModes.length;
                    this.instrumentMode = this.motionModes[nextIndex];
                    
                    // Update UI
                    document.getElementById('modeBtn').textContent = this.modeIcons[nextIndex];
                    this.padMode = (this.instrumentMode === 'pad');
                    document.getElementById('padModeIndicator').classList.toggle('show', this.padMode);
                    
                    this.showModeChange();
                    this.applyModeEffects();
                } catch (error) {
                    console.error('Shake handling failed:', error);
                }
            }

            showModeChange() {
                try {
                    const modeIndex = this.motionModes.indexOf(this.instrumentMode);
                    const modeName = this.motionModeNames[modeIndex];
                    const modeColor = this.motionModeColors[modeIndex];
                    
                    const indicator = document.createElement('div');
                    indicator.className = 'mode-indicator';
                    indicator.style.background = modeColor + 'CC';
                    indicator.style.color = 'white';
                    indicator.textContent = modeName;
                    document.body.appendChild(indicator);
                    
                    setTimeout(() => {
                        if (indicator.parentNode) {
                            indicator.remove();
                        }
                    }, 1800);
                } catch (error) {
                    console.error('Mode change display failed:', error);
                }
            }

            applyModeEffects() {
                try {
                    // Clear existing auto effects
                    if (this.autoRhythmInterval) {
                        clearInterval(this.autoRhythmInterval);
                        this.autoRhythmInterval = null;
                    }
                    
                    // Apply mode-specific effects
                    switch(this.instrumentMode) {
                        case 'percussion':
                            this.startAutoRhythm();
                            break;
                        case 'effects':
                            this.triggerEffectBurst();
                            break;
                        case 'ambient':
                            this.triggerAmbientTone();
                            break;
                    }
                } catch (error) {
                    console.error('Mode effects application failed:', error);
                }
            }

            startAutoRhythm() {
                try {
                    if (this.autoRhythmInterval) return;
                    
                    const pattern = [1, 0, 1, 0, 1, 0, 1, 1];
                    this.rhythmStep = 0;
                    
                    this.autoRhythmInterval = setInterval(() => {
                        if (pattern[this.rhythmStep % pattern.length] && this.isStarted) {
                            this.playBeat(this.rhythmStep % 3);
                            this.showRhythmBeat();
                        }
                        this.rhythmStep++;
                    }, 300);
                } catch (error) {
                    console.error('Auto rhythm start failed:', error);
                }
            }

            triggerEffectBurst() {
                try {
                    for (let i = 0; i < 3; i++) {
                        setTimeout(() => {
                            if (this.isStarted) {
                                this.playBeat(i);
                            }
                        }, i * 100);
                    }
                } catch (error) {
                    console.error('Effect burst failed:', error);
                }
            }

            triggerAmbientTone() {
                if (!this.isStarted || !this.masterGain) return;
                
                try {
                    const synth = new Tone.Synth({
                        oscillator: { type: 'sine' },
                        envelope: { attack: 2, decay: 1, sustain: 0.8, release: 3 }
                    });
                    
                    synth.connect(this.masterGain);
                    synth.triggerAttackRelease(130.81, 4); // C3
                    
                    setTimeout(() => {
                        synth.dispose();
                    }, 5000);
                } catch (error) {
                    console.error('Ambient tone failed:', error);
                }
            }

            playBeat(beatIndex) {
                if (!this.isStarted || !this.masterGain) return;
                
                try {
                    if (this.sampleMode && this.customSamples.length > 0) {
                        const sample = this.customSamples[beatIndex % this.customSamples.length];
                        if (sample && sample.buffer) {
                            const player = new Tone.Player(sample.buffer);
                            player.connect(this.masterGain);
                            player.start();
                            setTimeout(() => player.dispose(), 2000);
                        }
                    } else {
                        const beat = this.beatSounds[beatIndex % this.beatSounds.length];
                        const osc = new Tone.Oscillator(beat.freq, 'sine');
                        const env = new Tone.AmplitudeEnvelope(0.01, beat.decay || 0.1, 0, 0.1);
                        
                        osc.connect(env);
                        env.connect(this.masterGain);
                        
                        osc.start();
                        env.triggerAttackRelease(0.1);
                        
                        setTimeout(() => {
                            osc.stop();
                            osc.dispose();
                            env.dispose();
                        }, 300);
                    }
                } catch (error) {
                    console.error('Beat playback failed:', error);
                }
            }

            showRhythmBeat() {
                try {
                    const x = Math.random() * window.innerWidth;
                    const y = Math.random() * window.innerHeight;
                    this.showBeatIndicator(x, y);
                } catch (error) {
                    console.error('Rhythm beat display failed:', error);
                }
            }

            showBeatIndicator(x, y) {
                try {
                    const indicator = document.createElement('div');
                    indicator.className = 'beat-indicator';
                    indicator.style.left = (x - 20) + 'px';
                    indicator.style.top = (y - 20) + 'px';
                    document.body.appendChild(indicator);
                    
                    setTimeout(() => {
                        if (indicator.parentNode) {
                            indicator.remove();
                        }
                    }, 300);
                } catch (error) {
                    console.error('Beat indicator display failed:', error);
                }
            }

            reset() {
                try {
                    this.stopAllNotes();
                    this.touches.clear();
                    this.padTouches = { note: null, effect: null };
                    this.instrumentMode = 'synth';
                    this.padMode = false;
                    
                    // Update UI
                    document.getElementById('modeBtn').textContent = this.modeIcons[0];
                    document.getElementById('padModeIndicator').classList.remove('show');
                    
                    if (this.autoRhythmInterval) {
                        clearInterval(this.autoRhythmInterval);
                        this.autoRhythmInterval = null;
                    }
                    
                    // Clear canvas
                    this.ctx.fillStyle = '#000';
                    this.ctx.fillRect(0, 0, window.innerWidth, window.innerHeight);
                    
                    console.log('App reset successfully');
                } catch (error) {
                    console.error('Reset failed:', error);
                }
            }

            stopAllNotes() {
                try {
                    // Stop all active synths
                    this.synths.forEach((synthData, id) => {
                        if (synthData && synthData.synth) {
                            synthData.synth.triggerRelease();
                            setTimeout(() => {
                                if (synthData.synth) {
                                    synthData.synth.dispose();
                                }
                            }, 1000);
                        }
                    });
                    
                    this.synths.clear();
                    this.activeSynths = 0;
                    
                    // Clear all timeouts
                    this.noteTimeouts.forEach(timeout => clearTimeout(timeout));
                    this.noteTimeouts.clear();
                } catch (error) {
                    console.error('Stop all notes failed:', error);
                }
            }

            // Touch event handlers
            handleTouchStart(e) {
                e.preventDefault();
                if (!this.isStarted) return;

                try {
                    for (let touch of e.changedTouches) {
                        const now = Date.now();
                        const timeSinceLastTap = now - this.lastTapTime;
                        
                        if (this.padMode) {
                            this.handlePadTouchStart(touch.identifier, touch.clientX, touch.clientY);
                        } else if (timeSinceLastTap < this.tapThreshold) {
                            this.triggerBeat(touch.clientX, touch.clientY);
                        } else {
                            this.startTouch(touch.identifier, touch.clientX, touch.clientY);
                        }
                        
                        this.lastTapTime = now;
                    }
                } catch (error) {
                    console.error('Touch start failed:', error);
                }
            }

            handleTouchMove(e) {
                e.preventDefault();
                if (!this.isStarted) return;

                try {
                    for (let touch of e.changedTouches) {
                        if (this.padMode) {
                            this.handlePadTouchMove(touch.identifier, touch.clientX, touch.clientY);
                        } else {
                            this.moveTouch(touch.identifier, touch.clientX, touch.clientY);
                        }
                    }
                } catch (error) {
                    console.error('Touch move failed:', error);
                }
            }

            handleTouchEnd(e) {
                e.preventDefault();
                
                try {
                    for (let touch of e.changedTouches) {
                        if (this.padMode) {
                            this.handlePadTouchEnd(touch.identifier);
                        } else {
                            this.endTouch(touch.identifier);
                        }
                    }
                } catch (error) {
                    console.error('Touch end failed:', error);
                }
            }

            // Pad mode handlers
            handlePadTouchStart(id, x, y) {
                try {
                    if (!this.padTouches.note) {
                        // First touch - play note
                        this.padTouches.note = id;
                        this.startTouch(id, x, y, true); // sustained mode
                    } else if (!this.padTouches.effect) {
                        // Second touch - apply effects
                        this.padTouches.effect = id;
                        this.touches.set(id, {
                            x, y, 
                            color: '#f9ca24', 
                            isEffect: true,
                            startTime: Date.now(),
                            trail: []
                        });
                        this.applyPadEffect(x, y);
                    }
                } catch (error) {
                    console.error('Pad touch start failed:', error);
                }
            }

            handlePadTouchMove(id, x, y) {
                try {
                    if (id === this.padTouches.note) {
                        this.moveTouch(id, x, y);
                    } else if (id === this.padTouches.effect) {
                        const touch = this.touches.get(id);
                        if (touch) {
                            touch.x = x;
                            touch.y = y;
                            touch.trail.push({ x, y, time: Date.now() });
                            if (touch.trail.length > this.maxTrailLength) {
                                touch.trail.shift();
                            }
                            this.applyPadEffect(x, y);
                        }
                    }
                } catch (error) {
                    console.error('Pad touch move failed:', error);
                }
            }

            handlePadTouchEnd(id) {
                try {
                    if (id === this.padTouches.note) {
                        this.endTouch(id);
                        this.padTouches.note = null;
                    } else if (id === this.padTouches.effect) {
                        this.touches.delete(id);
                        this.padTouches.effect = null;
                        this.resetPadEffects();
                    }
                } catch (error) {
                    console.error('Pad touch end failed:', error);
                }
            }

            applyPadEffect(x, y) {
                try {
                    const centerX = window.innerWidth / 2;
                    const centerY = window.innerHeight / 2;
                    const distance = Math.sqrt((x - centerX)**2 + (y - centerY)**2);
                    const maxDistance = Math.sqrt(centerX**2 + centerY**2);
                    const effectIntensity = Math.min(1, distance / maxDistance);
                    const effectType = Math.floor((x / window.innerWidth) * 3);
                    
                    switch(effectType) {
                        case 0: // Reverb
                            if (this.globalReverb && this.globalReverb.roomSize) {
                                this.globalReverb.roomSize.rampTo(effectIntensity * 0.8, 0.1);
                            }
                            break;
                        case 1: // Filter
                            if (this.globalFilter && this.globalFilter.frequency) {
                                const freq = 200 + (1 - effectIntensity) * 2800;
                                this.globalFilter.frequency.rampTo(freq, 0.1);
                            }
                            break;
                        case 2: // Distortion
                            if (this.globalDistortion) {
                                this.globalDistortion.distortion = effectIntensity * 0.5;
                            }
                            break;
                    }
                    
                    // Show effect visualization
                    this.showEffectVisualization(x, y, effectIntensity);
                } catch (error) {
                    console.error('Pad effect application failed:', error);
                }
            }

            resetPadEffects() {
                try {
                    if (this.globalReverb && this.globalReverb.roomSize) {
                        this.globalReverb.roomSize.rampTo(this.reverbAmount, 0.5);
                    }
                    if (this.globalFilter && this.globalFilter.frequency) {
                        this.globalFilter.frequency.rampTo(200 + (this.filterAmount * 3000), 0.5);
                    }
                    if (this.globalDistortion) {
                        this.globalDistortion.distortion = this.distortionAmount;
                    }
                } catch (error) {
                    console.error('Reset pad effects failed:', error);
                }
            }

            showEffectVisualization(x, y, intensity) {
                try {
                    const viz = document.createElement('div');
                    viz.className = 'effect-visualization';
                    viz.style.left = (x - 30) + 'px';
                    viz.style.top = (y - 30) + 'px';
                    viz.style.width = viz.style.height = '60px';
                    viz.style.borderColor = '#f9ca24';
                    viz.style.opacity = intensity;
                    document.body.appendChild(viz);
                    
                    setTimeout(() => {
                        if (viz.parentNode) {
                            viz.remove();
                        }
                    }, 1200);
                } catch (error) {
                    console.error('Effect visualization failed:', error);
                }
            }

            // Mouse event handlers for desktop testing
            handleMouseDown(e) {
                if (!this.isStarted) return;
                try {
                    if (this.padMode) {
                        this.handlePadTouchStart('mouse', e.clientX, e.clientY);
                    } else {
                        this.startTouch('mouse', e.clientX, e.clientY);
                    }
                } catch (error) {
                    console.error('Mouse down failed:', error);
                }
            }

            handleMouseMove(e) {
                if (!this.isStarted) return;
                try {
                    if (this.padMode) {
                        this.handlePadTouchMove('mouse', e.clientX, e.clientY);
                    } else if (this.touches.has('mouse')) {
                        this.moveTouch('mouse', e.clientX, e.clientY);
                    }
                } catch (error) {
                    console.error('Mouse move failed:', error);
                }
            }

            handleMouseUp(e) {
                try {
                    if (this.padMode) {
                        this.handlePadTouchEnd('mouse');
                    } else {
                        this.endTouch('mouse');
                    }
                } catch (error) {
                    console.error('Mouse up failed:', error);
                }
            }

            triggerBeat(x, y) {
                try {
                    const beatIndex = Math.floor((x / window.innerWidth) * 3);
                    this.playBeat(beatIndex);
                    this.showBeatIndicator(x, y);
                } catch (error) {
                    console.error('Trigger beat failed:', error);
                }
            }

            startTouch(id, x, y, sustained = false) {
                try {
                    if (this.activeSynths >= this.maxPolyphony) return;
                    
                    const frequency = this.getFrequencyFromPosition(x, y);
                    const color = this.colors[this.activeSynths % this.colors.length];
                    
                    // Create synth with appropriate envelope for sustained or normal play
                    const synth = new Tone.Synth({
                        oscillator: { type: this.currentWave },
                        envelope: sustained ? 
                            { attack: 0.3, decay: 0.1, sustain: 0.9, release: 2.0 } : 
                            { attack: 0.1, decay: 0.3, sustain: 0.7, release: 1.0 }
                    });
                    
                    synth.connect(this.masterGain);
                    synth.triggerAttack(frequency);
                    
                    this.synths.set(id, { synth, startTime: Date.now() });
                    this.activeSynths++;
                    
                    this.touches.set(id, {
                        x, y, color, frequency, 
                        startTime: Date.now(), 
                        trail: [], 
                        isEffect: false
                    });
                    
                    // Set stuck note protection
                    const timeout = setTimeout(() => this.endTouch(id), this.stuckNoteTimeout);
                    this.noteTimeouts.set(id, timeout);
                    
                } catch (error) {
                    console.error('Start touch failed:', error);
                }
            }

            moveTouch(id, x, y) {
                try {
                    const touch = this.touches.get(id);
                    const synthData = this.synths.get(id);
                    
                    if (!touch || !synthData || touch.isEffect) return;
                    
                    const frequency = this.getFrequencyFromPosition(x, y);
                    
                    if (synthData.synth) {
                        synthData.synth.frequency.rampTo(frequency, 0.05);
                    }
                    
                    // Update trail with performance optimization
                    touch.trail.push({ x, y, time: Date.now() });
                    if (touch.trail.length > this.maxTrailLength) {
                        touch.trail.shift();
                    }
                    
                    touch.x = x;
                    touch.y = y;
                    touch.frequency = frequency;
                } catch (error) {
                    console.error('Move touch failed:', error);
                }
            }

            endTouch(id) {
                try {
                    const synthData = this.synths.get(id);
                    if (synthData && synthData.synth) {
                        synthData.synth.triggerRelease();
                        setTimeout(() => {
                            if (synthData.synth) {
                                synthData.synth.dispose();
                            }
                        }, 1000);
                        
                        this.activeSynths = Math.max(0, this.activeSynths - 1);
                    }
                    
                    this.synths.delete(id);
                    this.touches.delete(id);
                    
                    if (this.noteTimeouts.has(id)) {
                        clearTimeout(this.noteTimeouts.get(id));
                        this.noteTimeouts.delete(id);
                    }
                } catch (error) {
                    console.error('End touch failed:', error);
                }
            }

            getFrequencyFromPosition(x, y) {
                try {
                    const scale = this.scales[this.currentScale];
                    const noteIndex = Math.floor((x / window.innerWidth) * scale.length);
                    const baseFreq = scale[Math.min(noteIndex, scale.length - 1)];
                    const octaveMultiplier = Math.pow(2, Math.floor((1 - y / window.innerHeight) * 2));
                    const frequency = Math.min(1200, baseFreq * octaveMultiplier);
                    
                    // Apply touch sensitivity
                    return frequency * (0.5 + (this.touchSensitivity * 0.5));
                } catch (error) {
                    console.error('Frequency calculation failed:', error);
                    return 440; // Fallback to A4
                }
            }

            // Animation loop with performance optimization
            startAnimationLoop() {
                const animate = (currentTime) => {
                    try {
                        if (currentTime - this.lastFrameTime >= 1000 / this.targetFPS) {
                            this.draw();
                            this.lastFrameTime = currentTime;
                        }
                        this.animationId = requestAnimationFrame(animate);
                    } catch (error) {
                        console.error('Animation loop failed:', error);
                    }
                };
                animate(0);
            }

            draw() {
                try {
                    // Clear canvas with fade effect
                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.08)';
                    this.ctx.fillRect(0, 0, window.innerWidth, window.innerHeight);
                    
                    // Draw all touches
                    this.touches.forEach((touch) => {
                        if (touch.isEffect) {
                            this.drawEffectTouch(touch);
                        } else {
                            this.drawTrail(touch);
                            this.drawTouch(touch);
                        }
                    });
                    
                    // Draw mode indicator when not in fullscreen
                    if (!this.isFullscreen) {
                        this.drawModeIndicator();
                    }
                } catch (error) {
                    console.error('Draw failed:', error);
                }
            }

            drawTrail(touch) {
                if (touch.trail.length < 2) return;
                
                try {
                    this.ctx.strokeStyle = touch.color;
                    this.ctx.lineWidth = 2;
                    this.ctx.lineCap = 'round';
                    this.ctx.globalAlpha = 0.6;
                    
                    this.ctx.beginPath();
                    for (let i = 0; i < touch.trail.length - 1; i++) {
                        const point = touch.trail[i];
                        const nextPoint = touch.trail[i + 1];
                        
                        if (i === 0) {
                            this.ctx.moveTo(point.x, point.y);
                        }
                        this.ctx.lineTo(nextPoint.x, nextPoint.y);
                    }
                    this.ctx.stroke();
                    this.ctx.globalAlpha = 1;
                } catch (error) {
                    console.error('Trail drawing failed:', error);
                }
            }

            drawTouch(touch) {
                try {
                    const pulse = Math.sin(Date.now() * 0.005) * 0.2 + 0.8;
                    
                    // Outer glow
                    const gradient = this.ctx.createRadialGradient(
                        touch.x, touch.y, 0, touch.x, touch.y, 30
                    );
                    gradient.addColorStop(0, touch.color + '88');
                    gradient.addColorStop(1, touch.color + '00');
                    
                    this.ctx.fillStyle = gradient;
                    this.ctx.beginPath();
                    this.ctx.arc(touch.x, touch.y, 30 * pulse, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Center dot
                    this.ctx.fillStyle = touch.color;
                    this.ctx.beginPath();
                    this.ctx.arc(touch.x, touch.y, 6 * pulse, 0, Math.PI * 2);
                    this.ctx.fill();
                } catch (error) {
                    console.error('Touch drawing failed:', error);
                }
            }

            drawEffectTouch(touch) {
                try {
                    const pulse = Math.sin(Date.now() * 0.008) * 0.3 + 0.7;
                    
                    // Effect touch ring
                    this.ctx.strokeStyle = touch.color + 'CC';
                    this.ctx.lineWidth = 3;
                    this.ctx.beginPath();
                    this.ctx.arc(touch.x, touch.y, 25 * pulse, 0, Math.PI * 2);
                    this.ctx.stroke();
                    
                    // Draw trail if available
                    if (touch.trail.length > 1) {
                        this.drawTrail(touch);
                    }
                    
                    // Center effect indicator
                    this.ctx.fillStyle = touch.color;
                    this.ctx.font = '16px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText('FX', touch.x, touch.y + 6);
                    this.ctx.textAlign = 'left';
                } catch (error) {
                    console.error('Effect touch drawing failed:', error);
                }
            }

            drawModeIndicator() {
                try {
                    const modeIndex = this.motionModes.indexOf(this.instrumentMode);
                    const modeName = this.motionModeNames[modeIndex];
                    const modeColor = this.motionModeColors[modeIndex];
                    
                    // Background
                    this.ctx.fillStyle = modeColor + '44';
                    this.ctx.fillRect(window.innerWidth - 80, window.innerHeight - 30, 70, 20);
                    
                    // Text
                    this.ctx.fillStyle = modeColor;
                    this.ctx.font = '12px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText(modeName, window.innerWidth - 45, window.innerHeight - 16);
                    this.ctx.textAlign = 'left';
                } catch (error) {
                    console.error('Mode indicator drawing failed:', error);
                }
            }
        }

        // Initialize the application
        window.addEventListener('load', () => {
            try {
                const app = new TouchSynth();
                window.touchSynth = app; // Global reference for debugging
                console.log('TouchSynth application loaded successfully');
            } catch (error) {
                console.error('App initialization failed:', error);
                document.body.innerHTML = `
                    <div style="color: red; text-align: center; padding: 50px; font-size: 16px;">
                        <h2>App Failed to Load</h2>
                        <p>Error: ${error.message}</p>
                        <p>Please refresh the page to try again.</p>
                    </div>
                `;
            }
        });

        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            try {
                if (window.touchSynth) {
                    window.touchSynth.stopAllNotes();
                }
            } catch (error) {
                console.error('Cleanup failed:', error);
            }
        });
    </script>
</body>
</html>